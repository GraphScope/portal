/* tslint:disable */
/* eslint-disable */
/**
 * GraphScope FLEX HTTP SERVICE API
 * This is a specification for GraphScope FLEX HTTP service based on the OpenAPI 3.0 specification. You can find out more details about specification at [doc](https://swagger.io/specification/v3/).  Some useful links: - [GraphScope Repository](https://github.com/alibaba/GraphScope) - [The Source API definition for GraphScope Interactive](https://github.com/GraphScope/portal/tree/main/httpservice)
 *
 * The version of the OpenAPI document: 0.9.1
 * Contact: graphscope@alibaba-inc.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AlertMessage
 */
export interface AlertMessage {
    /**
     * Generated in server side
     * @type {string}
     * @memberof AlertMessage
     */
    'message_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertMessage
     */
    'alert_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertMessage
     */
    'severity'?: AlertMessageSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof AlertMessage
     */
    'metric_type'?: AlertMessageMetricTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertMessage
     */
    'target'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AlertMessage
     */
    'trigger_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertMessage
     */
    'status'?: AlertMessageStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AlertMessage
     */
    'message'?: string;
}

export const AlertMessageSeverityEnum = {
    Warning: 'warning',
    Emergency: 'emergency'
} as const;

export type AlertMessageSeverityEnum = typeof AlertMessageSeverityEnum[keyof typeof AlertMessageSeverityEnum];
export const AlertMessageMetricTypeEnum = {
    Node: 'node',
    Service: 'service'
} as const;

export type AlertMessageMetricTypeEnum = typeof AlertMessageMetricTypeEnum[keyof typeof AlertMessageMetricTypeEnum];
export const AlertMessageStatusEnum = {
    Unsolved: 'unsolved',
    Solved: 'solved',
    Dealing: 'dealing'
} as const;

export type AlertMessageStatusEnum = typeof AlertMessageStatusEnum[keyof typeof AlertMessageStatusEnum];

/**
 * 
 * @export
 * @interface AlertReceiver
 */
export interface AlertReceiver {
    /**
     * 
     * @type {string}
     * @memberof AlertReceiver
     */
    'type'?: AlertReceiverTypeEnum;
    /**
     * Generated in server side
     * @type {string}
     * @memberof AlertReceiver
     */
    'receiver_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiver
     */
    'webhook_url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertReceiver
     */
    'at_user_ids'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof AlertReceiver
     */
    'is_at_all'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertReceiver
     */
    'enable'?: boolean;
    /**
     * error message generated in server side
     * @type {string}
     * @memberof AlertReceiver
     */
    'message'?: string;
}

export const AlertReceiverTypeEnum = {
    Webhook: 'webhook'
} as const;

export type AlertReceiverTypeEnum = typeof AlertReceiverTypeEnum[keyof typeof AlertReceiverTypeEnum];

/**
 * 
 * @export
 * @interface AlertRule
 */
export interface AlertRule {
    /**
     * 
     * @type {string}
     * @memberof AlertRule
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertRule
     */
    'severity'?: AlertRuleSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof AlertRule
     */
    'metric_type'?: AlertRuleMetricTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AlertRule
     */
    'conditions_description'?: string;
    /**
     * (mins)
     * @type {number}
     * @memberof AlertRule
     */
    'frequency'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AlertRule
     */
    'enable'?: boolean;
}

export const AlertRuleSeverityEnum = {
    Warning: 'warning',
    Emergency: 'emergency'
} as const;

export type AlertRuleSeverityEnum = typeof AlertRuleSeverityEnum[keyof typeof AlertRuleSeverityEnum];
export const AlertRuleMetricTypeEnum = {
    Node: 'node',
    Service: 'service'
} as const;

export type AlertRuleMetricTypeEnum = typeof AlertRuleMetricTypeEnum[keyof typeof AlertRuleMetricTypeEnum];

/**
 * 
 * @export
 * @interface ColumnMapping
 */
export interface ColumnMapping {
    /**
     * 
     * @type {EdgeMappingSourceVertexMappingsInnerColumn}
     * @memberof ColumnMapping
     */
    'column'?: EdgeMappingSourceVertexMappingsInnerColumn;
    /**
     * must align with the schema
     * @type {string}
     * @memberof ColumnMapping
     */
    'property'?: string;
}
/**
 * 
 * @export
 * @interface Connection
 */
export interface Connection {
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'coordinator_endpoint'?: string;
}
/**
 * 
 * @export
 * @interface ConnectionStatus
 */
export interface ConnectionStatus {
    /**
     * 
     * @type {string}
     * @memberof ConnectionStatus
     */
    'status'?: ConnectionStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ConnectionStatus
     */
    'solution'?: ConnectionStatusSolutionEnum;
}

export const ConnectionStatusStatusEnum = {
    Connected: 'CONNECTED'
} as const;

export type ConnectionStatusStatusEnum = typeof ConnectionStatusStatusEnum[keyof typeof ConnectionStatusStatusEnum];
export const ConnectionStatusSolutionEnum = {
    Interactive: 'INTERACTIVE',
    GraphscopeInsight: 'GRAPHSCOPE_INSIGHT'
} as const;

export type ConnectionStatusSolutionEnum = typeof ConnectionStatusSolutionEnum[keyof typeof ConnectionStatusSolutionEnum];

/**
 * 
 * @export
 * @interface DataSource
 */
export interface DataSource {
    /**
     * 
     * @type {Array<VertexDataSource>}
     * @memberof DataSource
     */
    'vertices_datasource'?: Array<VertexDataSource>;
    /**
     * 
     * @type {Array<EdgeDataSource>}
     * @memberof DataSource
     */
    'edges_datasource'?: Array<EdgeDataSource>;
}
/**
 * 
 * @export
 * @interface DeploymentInfo
 */
export interface DeploymentInfo {
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'cluster_type'?: DeploymentInfoClusterTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'solution'?: DeploymentInfoSolutionEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfo
     */
    'creation_time'?: string;
    /**
     * 
     * @type {{ [key: string]: DeploymentInfoGraphsInfoValue; }}
     * @memberof DeploymentInfo
     */
    'graphs_info'?: { [key: string]: DeploymentInfoGraphsInfoValue; };
}

export const DeploymentInfoClusterTypeEnum = {
    Hosts: 'HOSTS',
    Kubernetes: 'KUBERNETES'
} as const;

export type DeploymentInfoClusterTypeEnum = typeof DeploymentInfoClusterTypeEnum[keyof typeof DeploymentInfoClusterTypeEnum];
export const DeploymentInfoSolutionEnum = {
    Interactive: 'INTERACTIVE',
    GraphscopeInsight: 'GRAPHSCOPE_INSIGHT'
} as const;

export type DeploymentInfoSolutionEnum = typeof DeploymentInfoSolutionEnum[keyof typeof DeploymentInfoSolutionEnum];

/**
 * 
 * @export
 * @interface DeploymentInfoGraphsInfoValue
 */
export interface DeploymentInfoGraphsInfoValue {
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfoGraphsInfoValue
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfoGraphsInfoValue
     */
    'creation_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfoGraphsInfoValue
     */
    'update_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentInfoGraphsInfoValue
     */
    'last_dataloading_time'?: string;
}
/**
 * K8s only
 * @export
 * @interface DeploymentStatus
 */
export interface DeploymentStatus {
    /**
     * 
     * @type {string}
     * @memberof DeploymentStatus
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentStatus
     */
    'container'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentStatus
     */
    'image'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentStatus
     */
    'labels'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStatus
     */
    'node'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStatus
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentStatus
     */
    'restart_count'?: number;
    /**
     * cpu value in millicore
     * @type {number}
     * @memberof DeploymentStatus
     */
    'cpu_value'?: number;
    /**
     * memory value in megabytes
     * @type {number}
     * @memberof DeploymentStatus
     */
    'memory_value'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStatus
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStatus
     */
    'creation_time'?: string;
}
/**
 * 
 * @export
 * @interface EdgeDataSource
 */
export interface EdgeDataSource {
    /**
     * 
     * @type {string}
     * @memberof EdgeDataSource
     */
    'data_source'?: EdgeDataSourceDataSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof EdgeDataSource
     */
    'type_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeDataSource
     */
    'source_vertex'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeDataSource
     */
    'destination_vertex'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeDataSource
     */
    'location'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EdgeDataSource
     */
    'source_pk_column_map'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EdgeDataSource
     */
    'destination_pk_column_map'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EdgeDataSource
     */
    'property_mapping'?: { [key: string]: any; };
}

export const EdgeDataSourceDataSourceEnum = {
    Odps: 'ODPS',
    File: 'FILE'
} as const;

export type EdgeDataSourceDataSourceEnum = typeof EdgeDataSourceDataSourceEnum[keyof typeof EdgeDataSourceDataSourceEnum];

/**
 * 
 * @export
 * @interface EdgeMapping
 */
export interface EdgeMapping {
    /**
     * 
     * @type {EdgeMappingTypeTriplet}
     * @memberof EdgeMapping
     */
    'type_triplet'?: EdgeMappingTypeTriplet;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgeMapping
     */
    'inputs'?: Array<string>;
    /**
     * 
     * @type {Array<EdgeMappingSourceVertexMappingsInner>}
     * @memberof EdgeMapping
     */
    'source_vertex_mappings'?: Array<EdgeMappingSourceVertexMappingsInner>;
    /**
     * 
     * @type {Array<EdgeMappingDestinationVertexMappingsInner>}
     * @memberof EdgeMapping
     */
    'destination_vertex_mappings'?: Array<EdgeMappingDestinationVertexMappingsInner>;
    /**
     * 
     * @type {Array<ColumnMapping>}
     * @memberof EdgeMapping
     */
    'column_mappings'?: Array<ColumnMapping>;
}
/**
 * Mapping column index to the primary key of destination vertex
 * @export
 * @interface EdgeMappingDestinationVertexMappingsInner
 */
export interface EdgeMappingDestinationVertexMappingsInner {
    /**
     * 
     * @type {EdgeMappingSourceVertexMappingsInnerColumn}
     * @memberof EdgeMappingDestinationVertexMappingsInner
     */
    'column'?: EdgeMappingSourceVertexMappingsInnerColumn;
}
/**
 * Mapping column index to the primary key of source vertex
 * @export
 * @interface EdgeMappingSourceVertexMappingsInner
 */
export interface EdgeMappingSourceVertexMappingsInner {
    /**
     * 
     * @type {EdgeMappingSourceVertexMappingsInnerColumn}
     * @memberof EdgeMappingSourceVertexMappingsInner
     */
    'column'?: EdgeMappingSourceVertexMappingsInnerColumn;
}
/**
 * 
 * @export
 * @interface EdgeMappingSourceVertexMappingsInnerColumn
 */
export interface EdgeMappingSourceVertexMappingsInnerColumn {
    /**
     * 
     * @type {number}
     * @memberof EdgeMappingSourceVertexMappingsInnerColumn
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof EdgeMappingSourceVertexMappingsInnerColumn
     */
    'name'?: string;
}
/**
 * source label -> [edge label] -> destination label
 * @export
 * @interface EdgeMappingTypeTriplet
 */
export interface EdgeMappingTypeTriplet {
    /**
     * 
     * @type {string}
     * @memberof EdgeMappingTypeTriplet
     */
    'edge'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeMappingTypeTriplet
     */
    'source_vertex'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeMappingTypeTriplet
     */
    'destination_vertex'?: string;
}
/**
 * 
 * @export
 * @interface EdgeType
 */
export interface EdgeType {
    /**
     * 
     * @type {number}
     * @memberof EdgeType
     */
    'type_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EdgeType
     */
    'type_name'?: string;
    /**
     * 
     * @type {Array<EdgeTypeVertexTypePairRelationsInner>}
     * @memberof EdgeType
     */
    'vertex_type_pair_relations'?: Array<EdgeTypeVertexTypePairRelationsInner>;
    /**
     * 
     * @type {Array<Property>}
     * @memberof EdgeType
     */
    'properties'?: Array<Property>;
}
/**
 * 
 * @export
 * @interface EdgeTypeVertexTypePairRelationsInner
 */
export interface EdgeTypeVertexTypePairRelationsInner {
    /**
     * 
     * @type {string}
     * @memberof EdgeTypeVertexTypePairRelationsInner
     */
    'source_vertex'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeTypeVertexTypePairRelationsInner
     */
    'destination_vertex'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeTypeVertexTypePairRelationsInner
     */
    'relation'?: EdgeTypeVertexTypePairRelationsInnerRelationEnum;
    /**
     * 
     * @type {EdgeTypeVertexTypePairRelationsInnerXCsrParams}
     * @memberof EdgeTypeVertexTypePairRelationsInner
     */
    'x_csr_params'?: EdgeTypeVertexTypePairRelationsInnerXCsrParams;
}

export const EdgeTypeVertexTypePairRelationsInnerRelationEnum = {
    ManyToMany: 'MANY_TO_MANY',
    OneToMany: 'ONE_TO_MANY',
    ManyToOne: 'MANY_TO_ONE',
    OneToOne: 'ONE_TO_ONE'
} as const;

export type EdgeTypeVertexTypePairRelationsInnerRelationEnum = typeof EdgeTypeVertexTypePairRelationsInnerRelationEnum[keyof typeof EdgeTypeVertexTypePairRelationsInnerRelationEnum];

/**
 * Used for storage optimization
 * @export
 * @interface EdgeTypeVertexTypePairRelationsInnerXCsrParams
 */
export interface EdgeTypeVertexTypePairRelationsInnerXCsrParams {
    /**
     * 
     * @type {string}
     * @memberof EdgeTypeVertexTypePairRelationsInnerXCsrParams
     */
    'edge_storage_strategy'?: EdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum;
}

export const EdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum = {
    OnlyIn: 'ONLY_IN',
    OnlyOut: 'ONLY_OUT',
    BothOutIn: 'BOTH_OUT_IN'
} as const;

export type EdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum = typeof EdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum[keyof typeof EdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum];

/**
 * 
 * @export
 * @interface Graph
 */
export interface Graph {
    /**
     * 
     * @type {string}
     * @memberof Graph
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Graph
     */
    'store_type'?: GraphStoreTypeEnum;
    /**
     * 
     * @type {GraphStoredProcedures}
     * @memberof Graph
     */
    'stored_procedures'?: GraphStoredProcedures;
    /**
     * 
     * @type {Schema}
     * @memberof Graph
     */
    'schema'?: Schema;
}

export const GraphStoreTypeEnum = {
    MutableCsr: 'mutable_csr'
} as const;

export type GraphStoreTypeEnum = typeof GraphStoreTypeEnum[keyof typeof GraphStoreTypeEnum];

/**
 * 
 * @export
 * @interface GraphStoredProcedures
 */
export interface GraphStoredProcedures {
    /**
     * 
     * @type {string}
     * @memberof GraphStoredProcedures
     */
    'directory'?: GraphStoredProceduresDirectoryEnum;
}

export const GraphStoredProceduresDirectoryEnum = {
    Plugins: 'plugins'
} as const;

export type GraphStoredProceduresDirectoryEnum = typeof GraphStoredProceduresDirectoryEnum[keyof typeof GraphStoredProceduresDirectoryEnum];

/**
 * 
 * @export
 * @interface GrootEdgeType
 */
export interface GrootEdgeType {
    /**
     * 
     * @type {string}
     * @memberof GrootEdgeType
     */
    'label'?: string;
    /**
     * 
     * @type {Array<GrootEdgeTypeRelationsInner>}
     * @memberof GrootEdgeType
     */
    'relations'?: Array<GrootEdgeTypeRelationsInner>;
    /**
     * 
     * @type {Array<GrootProperty>}
     * @memberof GrootEdgeType
     */
    'properties'?: Array<GrootProperty>;
}
/**
 * 
 * @export
 * @interface GrootEdgeTypeRelationsInner
 */
export interface GrootEdgeTypeRelationsInner {
    /**
     * 
     * @type {string}
     * @memberof GrootEdgeTypeRelationsInner
     */
    'src_label'?: string;
    /**
     * 
     * @type {string}
     * @memberof GrootEdgeTypeRelationsInner
     */
    'dst_label'?: string;
}
/**
 * 
 * @export
 * @interface GrootGraph
 */
export interface GrootGraph {
    /**
     * 
     * @type {string}
     * @memberof GrootGraph
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GrootGraph
     */
    'type'?: GrootGraphTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GrootGraph
     */
    'directed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GrootGraph
     */
    'creation_time'?: string;
    /**
     * 
     * @type {GrootSchema}
     * @memberof GrootGraph
     */
    'schema'?: GrootSchema;
    /**
     * 
     * @type {GrootGraphGremlinInterface}
     * @memberof GrootGraph
     */
    'gremlin_interface'?: GrootGraphGremlinInterface;
}

export const GrootGraphTypeEnum = {
    GrootGraph: 'GrootGraph'
} as const;

export type GrootGraphTypeEnum = typeof GrootGraphTypeEnum[keyof typeof GrootGraphTypeEnum];

/**
 * 
 * @export
 * @interface GrootGraphGremlinInterface
 */
export interface GrootGraphGremlinInterface {
    /**
     * 
     * @type {string}
     * @memberof GrootGraphGremlinInterface
     */
    'gremlin_endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof GrootGraphGremlinInterface
     */
    'grpc_endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof GrootGraphGremlinInterface
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof GrootGraphGremlinInterface
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface GrootProperty
 */
export interface GrootProperty {
    /**
     * 
     * @type {number}
     * @memberof GrootProperty
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GrootProperty
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GrootProperty
     */
    'type'?: GrootPropertyTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GrootProperty
     */
    'is_primary_key'?: boolean;
}

export const GrootPropertyTypeEnum = {
    String: 'STRING',
    Long: 'LONG',
    Double: 'DOUBLE'
} as const;

export type GrootPropertyTypeEnum = typeof GrootPropertyTypeEnum[keyof typeof GrootPropertyTypeEnum];

/**
 * 
 * @export
 * @interface GrootSchema
 */
export interface GrootSchema {
    /**
     * 
     * @type {Array<GrootVertexType>}
     * @memberof GrootSchema
     */
    'vertices'?: Array<GrootVertexType>;
    /**
     * 
     * @type {Array<GrootEdgeType>}
     * @memberof GrootSchema
     */
    'edges'?: Array<GrootEdgeType>;
}
/**
 * 
 * @export
 * @interface GrootVertexType
 */
export interface GrootVertexType {
    /**
     * 
     * @type {string}
     * @memberof GrootVertexType
     */
    'label'?: string;
    /**
     * 
     * @type {Array<GrootProperty>}
     * @memberof GrootVertexType
     */
    'properties'?: Array<GrootProperty>;
}
/**
 * 
 * @export
 * @interface JobStatus
 */
export interface JobStatus {
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'job_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'status'?: JobStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'end_time'?: string;
    /**
     * URL or log string
     * @type {string}
     * @memberof JobStatus
     */
    'log'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobStatus
     */
    'detail'?: { [key: string]: any; };
}

export const JobStatusStatusEnum = {
    Running: 'RUNNING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Cancelled: 'CANCELLED',
    Waiting: 'WAITING'
} as const;

export type JobStatusStatusEnum = typeof JobStatusStatusEnum[keyof typeof JobStatusStatusEnum];

/**
 * 
 * @export
 * @interface NodeStatus
 */
export interface NodeStatus {
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    'node'?: string;
    /**
     * 
     * @type {number}
     * @memberof NodeStatus
     */
    'cpu_usage'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeStatus
     */
    'memory_usage'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeStatus
     */
    'disk_usage'?: number;
}
/**
 * 
 * @export
 * @interface Procedure
 */
export interface Procedure {
    /**
     * 
     * @type {string}
     * @memberof Procedure
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Procedure
     */
    'bound_graph'?: string;
    /**
     * 
     * @type {string}
     * @memberof Procedure
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Procedure
     */
    'type'?: ProcedureTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Procedure
     */
    'query'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Procedure
     */
    'enable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Procedure
     */
    'runnable'?: boolean;
    /**
     * 
     * @type {Array<ProcedureParamsInner>}
     * @memberof Procedure
     */
    'params'?: Array<ProcedureParamsInner>;
    /**
     * 
     * @type {Array<ProcedureParamsInner>}
     * @memberof Procedure
     */
    'returns'?: Array<ProcedureParamsInner>;
}

export const ProcedureTypeEnum = {
    Cpp: 'cpp',
    Cypher: 'cypher'
} as const;

export type ProcedureTypeEnum = typeof ProcedureTypeEnum[keyof typeof ProcedureTypeEnum];

/**
 * 
 * @export
 * @interface ProcedureParamsInner
 */
export interface ProcedureParamsInner {
    /**
     * 
     * @type {string}
     * @memberof ProcedureParamsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcedureParamsInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    'property_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'property_name'?: string;
    /**
     * 
     * @type {PropertyPropertyType}
     * @memberof Property
     */
    'property_type'?: PropertyPropertyType;
}
/**
 * 
 * @export
 * @interface PropertyPropertyType
 */
export interface PropertyPropertyType {
    /**
     * 
     * @type {string}
     * @memberof PropertyPropertyType
     */
    'primitive_type'?: PropertyPropertyTypePrimitiveTypeEnum;
}

export const PropertyPropertyTypePrimitiveTypeEnum = {
    Double: 'DT_DOUBLE',
    String: 'DT_STRING',
    SignedInt32: 'DT_SIGNED_INT32',
    SignedInt64: 'DT_SIGNED_INT64',
    Date32: 'DT_DATE32'
} as const;

export type PropertyPropertyTypePrimitiveTypeEnum = typeof PropertyPropertyTypePrimitiveTypeEnum[keyof typeof PropertyPropertyTypePrimitiveTypeEnum];

/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {Array<VertexType>}
     * @memberof Schema
     */
    'vertex_types'?: Array<VertexType>;
    /**
     * 
     * @type {Array<EdgeType>}
     * @memberof Schema
     */
    'edge_types'?: Array<EdgeType>;
}
/**
 * 
 * @export
 * @interface SchemaMapping
 */
export interface SchemaMapping {
    /**
     * 
     * @type {string}
     * @memberof SchemaMapping
     */
    'graph'?: string;
    /**
     * 
     * @type {SchemaMappingLoadingConfig}
     * @memberof SchemaMapping
     */
    'loading_config'?: SchemaMappingLoadingConfig;
    /**
     * 
     * @type {Array<VertexMapping>}
     * @memberof SchemaMapping
     */
    'vertex_mappings'?: Array<VertexMapping>;
    /**
     * 
     * @type {Array<EdgeMapping>}
     * @memberof SchemaMapping
     */
    'edge_mappings'?: Array<EdgeMapping>;
}
/**
 * 
 * @export
 * @interface SchemaMappingLoadingConfig
 */
export interface SchemaMappingLoadingConfig {
    /**
     * 
     * @type {SchemaMappingLoadingConfigDataSource}
     * @memberof SchemaMappingLoadingConfig
     */
    'data_source'?: SchemaMappingLoadingConfigDataSource;
    /**
     * 
     * @type {string}
     * @memberof SchemaMappingLoadingConfig
     */
    'import_option'?: SchemaMappingLoadingConfigImportOptionEnum;
    /**
     * 
     * @type {SchemaMappingLoadingConfigFormat}
     * @memberof SchemaMappingLoadingConfig
     */
    'format'?: SchemaMappingLoadingConfigFormat;
}

export const SchemaMappingLoadingConfigImportOptionEnum = {
    Init: 'init',
    Overwrite: 'overwrite'
} as const;

export type SchemaMappingLoadingConfigImportOptionEnum = typeof SchemaMappingLoadingConfigImportOptionEnum[keyof typeof SchemaMappingLoadingConfigImportOptionEnum];

/**
 * 
 * @export
 * @interface SchemaMappingLoadingConfigDataSource
 */
export interface SchemaMappingLoadingConfigDataSource {
    /**
     * 
     * @type {string}
     * @memberof SchemaMappingLoadingConfigDataSource
     */
    'scheme'?: SchemaMappingLoadingConfigDataSourceSchemeEnum;
}

export const SchemaMappingLoadingConfigDataSourceSchemeEnum = {
    File: 'file'
} as const;

export type SchemaMappingLoadingConfigDataSourceSchemeEnum = typeof SchemaMappingLoadingConfigDataSourceSchemeEnum[keyof typeof SchemaMappingLoadingConfigDataSourceSchemeEnum];

/**
 * 
 * @export
 * @interface SchemaMappingLoadingConfigFormat
 */
export interface SchemaMappingLoadingConfigFormat {
    /**
     * 
     * @type {string}
     * @memberof SchemaMappingLoadingConfigFormat
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SchemaMappingLoadingConfigFormat
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ServiceStatus
 */
export interface ServiceStatus {
    /**
     * 
     * @type {string}
     * @memberof ServiceStatus
     */
    'status'?: string;
    /**
     * which graph is serving now
     * @type {string}
     * @memberof ServiceStatus
     */
    'graph_name'?: string;
    /**
     * 
     * @type {ServiceStatusSdkEndpoints}
     * @memberof ServiceStatus
     */
    'sdk_endpoints'?: ServiceStatusSdkEndpoints;
}
/**
 * 
 * @export
 * @interface ServiceStatusSdkEndpoints
 */
export interface ServiceStatusSdkEndpoints {
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusSdkEndpoints
     */
    'cypher'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusSdkEndpoints
     */
    'gremlin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusSdkEndpoints
     */
    'hqps'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusSdkEndpoints
     */
    'grpc'?: string;
}
/**
 * 
 * @export
 * @interface StartServiceRequest
 */
export interface StartServiceRequest {
    /**
     * 
     * @type {string}
     * @memberof StartServiceRequest
     */
    'graph_name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAlertMessagesRequest
 */
export interface UpdateAlertMessagesRequest {
    /**
     * 
     * @type {Array<AlertMessage>}
     * @memberof UpdateAlertMessagesRequest
     */
    'messages'?: Array<AlertMessage>;
    /**
     * Override the status of each message
     * @type {string}
     * @memberof UpdateAlertMessagesRequest
     */
    'batch_status'?: UpdateAlertMessagesRequestBatchStatusEnum;
    /**
     * True will delete all the messages in request body
     * @type {boolean}
     * @memberof UpdateAlertMessagesRequest
     */
    'batch_delete'?: boolean;
}

export const UpdateAlertMessagesRequestBatchStatusEnum = {
    Solved: 'solved',
    Unsolved: 'unsolved',
    Dealing: 'dealing'
} as const;

export type UpdateAlertMessagesRequestBatchStatusEnum = typeof UpdateAlertMessagesRequestBatchStatusEnum[keyof typeof UpdateAlertMessagesRequestBatchStatusEnum];

/**
 * 
 * @export
 * @interface VertexDataSource
 */
export interface VertexDataSource {
    /**
     * 
     * @type {string}
     * @memberof VertexDataSource
     */
    'data_source'?: VertexDataSourceDataSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof VertexDataSource
     */
    'type_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VertexDataSource
     */
    'location'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof VertexDataSource
     */
    'property_mapping'?: { [key: string]: any; };
}

export const VertexDataSourceDataSourceEnum = {
    Odps: 'ODPS',
    File: 'FILE'
} as const;

export type VertexDataSourceDataSourceEnum = typeof VertexDataSourceDataSourceEnum[keyof typeof VertexDataSourceDataSourceEnum];

/**
 * 
 * @export
 * @interface VertexMapping
 */
export interface VertexMapping {
    /**
     * 
     * @type {string}
     * @memberof VertexMapping
     */
    'type_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VertexMapping
     */
    'inputs'?: Array<string>;
    /**
     * 
     * @type {Array<ColumnMapping>}
     * @memberof VertexMapping
     */
    'column_mappings'?: Array<ColumnMapping>;
}
/**
 * 
 * @export
 * @interface VertexType
 */
export interface VertexType {
    /**
     * 
     * @type {number}
     * @memberof VertexType
     */
    'type_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof VertexType
     */
    'type_name'?: string;
    /**
     * 
     * @type {Array<Property>}
     * @memberof VertexType
     */
    'properties'?: Array<Property>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VertexType
     */
    'primary_keys'?: Array<string>;
}

/**
 * AlertApi - axios parameter creator
 * @export
 */
export const AlertApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertRuleByName: async (ruleName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleName' is not null or undefined
            assertParamExists('deleteAlertRuleByName', 'ruleName', ruleName)
            const localVarPath = `/api/v1/alert/rule/{rule_name}`
                .replace(`{${"rule_name"}}`, encodeURIComponent(String(ruleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} receiverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceiverById: async (receiverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receiverId' is not null or undefined
            assertParamExists('deleteReceiverById', 'receiverId', receiverId)
            const localVarPath = `/api/v1/alert/receiver/{receiver_id}`
                .replace(`{${"receiver_id"}}`, encodeURIComponent(String(receiverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [type] 
         * @param {ListAlertMessagesStatusEnum} [status] 
         * @param {ListAlertMessagesSeverityEnum} [severity] 
         * @param {string} [startTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {string} [endTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertMessages: async (type?: string, status?: ListAlertMessagesStatusEnum, severity?: ListAlertMessagesSeverityEnum, startTime?: string, endTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alert/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (severity !== undefined) {
                localVarQueryParameter['severity'] = severity;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alert/rule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alert/receiver`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AlertReceiver} alertReceiver 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerReceiver: async (alertReceiver: AlertReceiver, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertReceiver' is not null or undefined
            assertParamExists('registerReceiver', 'alertReceiver', alertReceiver)
            const localVarPath = `/api/v1/alert/receiver`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertReceiver, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update alert messages in batch
         * @param {UpdateAlertMessagesRequest} [updateAlertMessagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertMessages: async (updateAlertMessagesRequest?: UpdateAlertMessagesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alert/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAlertMessagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ruleName 
         * @param {AlertRule} [alertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertRuleByName: async (ruleName: string, alertRule?: AlertRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleName' is not null or undefined
            assertParamExists('updateAlertRuleByName', 'ruleName', ruleName)
            const localVarPath = `/api/v1/alert/rule/{rule_name}`
                .replace(`{${"rule_name"}}`, encodeURIComponent(String(ruleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} receiverId 
         * @param {AlertReceiver} [alertReceiver] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReceiverById: async (receiverId: string, alertReceiver?: AlertReceiver, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receiverId' is not null or undefined
            assertParamExists('updateReceiverById', 'receiverId', receiverId)
            const localVarPath = `/api/v1/alert/receiver/{receiver_id}`
                .replace(`{${"receiver_id"}}`, encodeURIComponent(String(receiverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertReceiver, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertApi - functional programming interface
 * @export
 */
export const AlertApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertRuleByName(ruleName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertRuleByName(ruleName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.deleteAlertRuleByName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} receiverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReceiverById(receiverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReceiverById(receiverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.deleteReceiverById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [type] 
         * @param {ListAlertMessagesStatusEnum} [status] 
         * @param {ListAlertMessagesSeverityEnum} [severity] 
         * @param {string} [startTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {string} [endTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertMessages(type?: string, status?: ListAlertMessagesStatusEnum, severity?: ListAlertMessagesSeverityEnum, startTime?: string, endTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertMessages(type, status, severity, startTime, endTime, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.listAlertMessages']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertRules(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.listAlertRules']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReceivers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertReceiver>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReceivers(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.listReceivers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {AlertReceiver} alertReceiver 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerReceiver(alertReceiver: AlertReceiver, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerReceiver(alertReceiver, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.registerReceiver']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update alert messages in batch
         * @param {UpdateAlertMessagesRequest} [updateAlertMessagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlertMessages(updateAlertMessagesRequest?: UpdateAlertMessagesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlertMessages(updateAlertMessagesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.updateAlertMessages']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} ruleName 
         * @param {AlertRule} [alertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlertRuleByName(ruleName: string, alertRule?: AlertRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlertRuleByName(ruleName, alertRule, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.updateAlertRuleByName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} receiverId 
         * @param {AlertReceiver} [alertReceiver] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReceiverById(receiverId: string, alertReceiver?: AlertReceiver, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReceiverById(receiverId, alertReceiver, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.updateReceiverById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AlertApi - factory interface
 * @export
 */
export const AlertApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertApiFp(configuration)
    return {
        /**
         * 
         * @param {string} ruleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertRuleByName(ruleName: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteAlertRuleByName(ruleName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} receiverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceiverById(receiverId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteReceiverById(receiverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [type] 
         * @param {ListAlertMessagesStatusEnum} [status] 
         * @param {ListAlertMessagesSeverityEnum} [severity] 
         * @param {string} [startTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {string} [endTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertMessages(type?: string, status?: ListAlertMessagesStatusEnum, severity?: ListAlertMessagesSeverityEnum, startTime?: string, endTime?: string, options?: any): AxiosPromise<Array<AlertMessage>> {
            return localVarFp.listAlertMessages(type, status, severity, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertRules(options?: any): AxiosPromise<Array<AlertRule>> {
            return localVarFp.listAlertRules(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivers(options?: any): AxiosPromise<Array<AlertReceiver>> {
            return localVarFp.listReceivers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AlertReceiver} alertReceiver 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerReceiver(alertReceiver: AlertReceiver, options?: any): AxiosPromise<string> {
            return localVarFp.registerReceiver(alertReceiver, options).then((request) => request(axios, basePath));
        },
        /**
         * Update alert messages in batch
         * @param {UpdateAlertMessagesRequest} [updateAlertMessagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertMessages(updateAlertMessagesRequest?: UpdateAlertMessagesRequest, options?: any): AxiosPromise<string> {
            return localVarFp.updateAlertMessages(updateAlertMessagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ruleName 
         * @param {AlertRule} [alertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertRuleByName(ruleName: string, alertRule?: AlertRule, options?: any): AxiosPromise<string> {
            return localVarFp.updateAlertRuleByName(ruleName, alertRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} receiverId 
         * @param {AlertReceiver} [alertReceiver] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReceiverById(receiverId: string, alertReceiver?: AlertReceiver, options?: any): AxiosPromise<string> {
            return localVarFp.updateReceiverById(receiverId, alertReceiver, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertApi - object-oriented interface
 * @export
 * @class AlertApi
 * @extends {BaseAPI}
 */
export class AlertApi extends BaseAPI {
    /**
     * 
     * @param {string} ruleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public deleteAlertRuleByName(ruleName: string, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).deleteAlertRuleByName(ruleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} receiverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public deleteReceiverById(receiverId: string, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).deleteReceiverById(receiverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [type] 
     * @param {ListAlertMessagesStatusEnum} [status] 
     * @param {ListAlertMessagesSeverityEnum} [severity] 
     * @param {string} [startTime] format with \&quot;2023-02-21-11-56-30\&quot;
     * @param {string} [endTime] format with \&quot;2023-02-21-11-56-30\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public listAlertMessages(type?: string, status?: ListAlertMessagesStatusEnum, severity?: ListAlertMessagesSeverityEnum, startTime?: string, endTime?: string, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).listAlertMessages(type, status, severity, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public listAlertRules(options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).listAlertRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public listReceivers(options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).listReceivers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlertReceiver} alertReceiver 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public registerReceiver(alertReceiver: AlertReceiver, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).registerReceiver(alertReceiver, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update alert messages in batch
     * @param {UpdateAlertMessagesRequest} [updateAlertMessagesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public updateAlertMessages(updateAlertMessagesRequest?: UpdateAlertMessagesRequest, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).updateAlertMessages(updateAlertMessagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ruleName 
     * @param {AlertRule} [alertRule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public updateAlertRuleByName(ruleName: string, alertRule?: AlertRule, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).updateAlertRuleByName(ruleName, alertRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} receiverId 
     * @param {AlertReceiver} [alertReceiver] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public updateReceiverById(receiverId: string, alertReceiver?: AlertReceiver, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).updateReceiverById(receiverId, alertReceiver, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListAlertMessagesStatusEnum = {
    Solved: 'solved',
    Unsolved: 'unsolved',
    Dealing: 'dealing'
} as const;
export type ListAlertMessagesStatusEnum = typeof ListAlertMessagesStatusEnum[keyof typeof ListAlertMessagesStatusEnum];
/**
 * @export
 */
export const ListAlertMessagesSeverityEnum = {
    Warning: 'warning',
    Emergency: 'emergency'
} as const;
export type ListAlertMessagesSeverityEnum = typeof ListAlertMessagesSeverityEnum[keyof typeof ListAlertMessagesSeverityEnum];


/**
 * ConnectionApi - axios parameter creator
 * @export
 */
export const ConnectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Close the connection with coordinator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        close: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect to coordinator service
         * @param {Connection} connection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect: async (connection: Connection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connection' is not null or undefined
            assertParamExists('connect', 'connection', connection)
            const localVarPath = `/api/v1/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionApi - functional programming interface
 * @export
 */
export const ConnectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionApiAxiosParamCreator(configuration)
    return {
        /**
         * Close the connection with coordinator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async close(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.close(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectionApi.close']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Connect to coordinator service
         * @param {Connection} connection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connect(connection: Connection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connect(connection, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectionApi.connect']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ConnectionApi - factory interface
 * @export
 */
export const ConnectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionApiFp(configuration)
    return {
        /**
         * Close the connection with coordinator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        close(options?: any): AxiosPromise<string> {
            return localVarFp.close(options).then((request) => request(axios, basePath));
        },
        /**
         * Connect to coordinator service
         * @param {Connection} connection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect(connection: Connection, options?: any): AxiosPromise<ConnectionStatus> {
            return localVarFp.connect(connection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectionApi - object-oriented interface
 * @export
 * @class ConnectionApi
 * @extends {BaseAPI}
 */
export class ConnectionApi extends BaseAPI {
    /**
     * Close the connection with coordinator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public close(options?: RawAxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).close(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect to coordinator service
     * @param {Connection} connection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionApi
     */
    public connect(connection: Connection, options?: RawAxiosRequestConfig) {
        return ConnectionApiFp(this.configuration).connect(connection, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasourceApi - axios parameter creator
 * @export
 */
export const DatasourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bind data source on edge type
         * @param {string} graphName 
         * @param {EdgeDataSource} edgeDataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindEdgeDatasource: async (graphName: string, edgeDataSource: EdgeDataSource, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('bindEdgeDatasource', 'graphName', graphName)
            // verify required parameter 'edgeDataSource' is not null or undefined
            assertParamExists('bindEdgeDatasource', 'edgeDataSource', edgeDataSource)
            const localVarPath = `/api/v1/graph/{graph_name}/datasource/edge_datasource`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(edgeDataSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bind data source on vertex type
         * @param {string} graphName 
         * @param {VertexDataSource} vertexDataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindVertexDatasource: async (graphName: string, vertexDataSource: VertexDataSource, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('bindVertexDatasource', 'graphName', graphName)
            // verify required parameter 'vertexDataSource' is not null or undefined
            assertParamExists('bindVertexDatasource', 'vertexDataSource', vertexDataSource)
            const localVarPath = `/api/v1/graph/{graph_name}/datasource/vertex_datasource`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vertexDataSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List data source on graph
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasource: async (graphName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('getDatasource', 'graphName', graphName)
            const localVarPath = `/api/v1/graph/{graph_name}/datasource`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get edge data source
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEdgeDatasource: async (graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('getEdgeDatasource', 'graphName', graphName)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('getEdgeDatasource', 'typeName', typeName)
            // verify required parameter 'sourceVertexType' is not null or undefined
            assertParamExists('getEdgeDatasource', 'sourceVertexType', sourceVertexType)
            // verify required parameter 'destinationVertexType' is not null or undefined
            assertParamExists('getEdgeDatasource', 'destinationVertexType', destinationVertexType)
            const localVarPath = `/api/v1/graph/{graph_name}/datasource/edge_datasource/{type_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceVertexType !== undefined) {
                localVarQueryParameter['source_vertex_type'] = sourceVertexType;
            }

            if (destinationVertexType !== undefined) {
                localVarQueryParameter['destination_vertex_type'] = destinationVertexType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get vertex data source
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVertexDatasource: async (graphName: string, typeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('getVertexDatasource', 'graphName', graphName)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('getVertexDatasource', 'typeName', typeName)
            const localVarPath = `/api/v1/graph/{graph_name}/datasource/vertex_datasource/{type_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import data source in batch
         * @param {string} graphName 
         * @param {DataSource} dataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDatasource: async (graphName: string, dataSource: DataSource, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('importDatasource', 'graphName', graphName)
            // verify required parameter 'dataSource' is not null or undefined
            assertParamExists('importDatasource', 'dataSource', dataSource)
            const localVarPath = `/api/v1/graph/{graph_name}/datasource`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unbind datasource on an edge type
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindEdgeDatasource: async (graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('unbindEdgeDatasource', 'graphName', graphName)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('unbindEdgeDatasource', 'typeName', typeName)
            // verify required parameter 'sourceVertexType' is not null or undefined
            assertParamExists('unbindEdgeDatasource', 'sourceVertexType', sourceVertexType)
            // verify required parameter 'destinationVertexType' is not null or undefined
            assertParamExists('unbindEdgeDatasource', 'destinationVertexType', destinationVertexType)
            const localVarPath = `/api/v1/graph/{graph_name}/datasource/edge_datasource/{type_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceVertexType !== undefined) {
                localVarQueryParameter['source_vertex_type'] = sourceVertexType;
            }

            if (destinationVertexType !== undefined) {
                localVarQueryParameter['destination_vertex_type'] = destinationVertexType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unbind datasource on a vertex type
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindVertexDatasource: async (graphName: string, typeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('unbindVertexDatasource', 'graphName', graphName)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('unbindVertexDatasource', 'typeName', typeName)
            const localVarPath = `/api/v1/graph/{graph_name}/datasource/vertex_datasource/{type_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasourceApi - functional programming interface
 * @export
 */
export const DatasourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Bind data source on edge type
         * @param {string} graphName 
         * @param {EdgeDataSource} edgeDataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindEdgeDatasource(graphName: string, edgeDataSource: EdgeDataSource, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindEdgeDatasource(graphName, edgeDataSource, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DatasourceApi.bindEdgeDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Bind data source on vertex type
         * @param {string} graphName 
         * @param {VertexDataSource} vertexDataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindVertexDatasource(graphName: string, vertexDataSource: VertexDataSource, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindVertexDatasource(graphName, vertexDataSource, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DatasourceApi.bindVertexDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List data source on graph
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasource(graphName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasource(graphName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DatasourceApi.getDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get edge data source
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEdgeDatasource(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EdgeDataSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEdgeDatasource(graphName, typeName, sourceVertexType, destinationVertexType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DatasourceApi.getEdgeDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get vertex data source
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVertexDatasource(graphName: string, typeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VertexDataSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVertexDatasource(graphName, typeName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DatasourceApi.getVertexDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Import data source in batch
         * @param {string} graphName 
         * @param {DataSource} dataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importDatasource(graphName: string, dataSource: DataSource, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importDatasource(graphName, dataSource, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DatasourceApi.importDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unbind datasource on an edge type
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindEdgeDatasource(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindEdgeDatasource(graphName, typeName, sourceVertexType, destinationVertexType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DatasourceApi.unbindEdgeDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unbind datasource on a vertex type
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindVertexDatasource(graphName: string, typeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindVertexDatasource(graphName, typeName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DatasourceApi.unbindVertexDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DatasourceApi - factory interface
 * @export
 */
export const DatasourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasourceApiFp(configuration)
    return {
        /**
         * Bind data source on edge type
         * @param {string} graphName 
         * @param {EdgeDataSource} edgeDataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindEdgeDatasource(graphName: string, edgeDataSource: EdgeDataSource, options?: any): AxiosPromise<string> {
            return localVarFp.bindEdgeDatasource(graphName, edgeDataSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Bind data source on vertex type
         * @param {string} graphName 
         * @param {VertexDataSource} vertexDataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindVertexDatasource(graphName: string, vertexDataSource: VertexDataSource, options?: any): AxiosPromise<string> {
            return localVarFp.bindVertexDatasource(graphName, vertexDataSource, options).then((request) => request(axios, basePath));
        },
        /**
         * List data source on graph
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasource(graphName: string, options?: any): AxiosPromise<DataSource> {
            return localVarFp.getDatasource(graphName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get edge data source
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEdgeDatasource(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: any): AxiosPromise<EdgeDataSource> {
            return localVarFp.getEdgeDatasource(graphName, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get vertex data source
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVertexDatasource(graphName: string, typeName: string, options?: any): AxiosPromise<VertexDataSource> {
            return localVarFp.getVertexDatasource(graphName, typeName, options).then((request) => request(axios, basePath));
        },
        /**
         * Import data source in batch
         * @param {string} graphName 
         * @param {DataSource} dataSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDatasource(graphName: string, dataSource: DataSource, options?: any): AxiosPromise<string> {
            return localVarFp.importDatasource(graphName, dataSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Unbind datasource on an edge type
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindEdgeDatasource(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: any): AxiosPromise<string> {
            return localVarFp.unbindEdgeDatasource(graphName, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(axios, basePath));
        },
        /**
         * Unbind datasource on a vertex type
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindVertexDatasource(graphName: string, typeName: string, options?: any): AxiosPromise<string> {
            return localVarFp.unbindVertexDatasource(graphName, typeName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasourceApi - object-oriented interface
 * @export
 * @class DatasourceApi
 * @extends {BaseAPI}
 */
export class DatasourceApi extends BaseAPI {
    /**
     * Bind data source on edge type
     * @param {string} graphName 
     * @param {EdgeDataSource} edgeDataSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourceApi
     */
    public bindEdgeDatasource(graphName: string, edgeDataSource: EdgeDataSource, options?: RawAxiosRequestConfig) {
        return DatasourceApiFp(this.configuration).bindEdgeDatasource(graphName, edgeDataSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bind data source on vertex type
     * @param {string} graphName 
     * @param {VertexDataSource} vertexDataSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourceApi
     */
    public bindVertexDatasource(graphName: string, vertexDataSource: VertexDataSource, options?: RawAxiosRequestConfig) {
        return DatasourceApiFp(this.configuration).bindVertexDatasource(graphName, vertexDataSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List data source on graph
     * @param {string} graphName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourceApi
     */
    public getDatasource(graphName: string, options?: RawAxiosRequestConfig) {
        return DatasourceApiFp(this.configuration).getDatasource(graphName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get edge data source
     * @param {string} graphName 
     * @param {string} typeName 
     * @param {string} sourceVertexType 
     * @param {string} destinationVertexType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourceApi
     */
    public getEdgeDatasource(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig) {
        return DatasourceApiFp(this.configuration).getEdgeDatasource(graphName, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get vertex data source
     * @param {string} graphName 
     * @param {string} typeName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourceApi
     */
    public getVertexDatasource(graphName: string, typeName: string, options?: RawAxiosRequestConfig) {
        return DatasourceApiFp(this.configuration).getVertexDatasource(graphName, typeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import data source in batch
     * @param {string} graphName 
     * @param {DataSource} dataSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourceApi
     */
    public importDatasource(graphName: string, dataSource: DataSource, options?: RawAxiosRequestConfig) {
        return DatasourceApiFp(this.configuration).importDatasource(graphName, dataSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unbind datasource on an edge type
     * @param {string} graphName 
     * @param {string} typeName 
     * @param {string} sourceVertexType 
     * @param {string} destinationVertexType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourceApi
     */
    public unbindEdgeDatasource(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig) {
        return DatasourceApiFp(this.configuration).unbindEdgeDatasource(graphName, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unbind datasource on a vertex type
     * @param {string} graphName 
     * @param {string} typeName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourceApi
     */
    public unbindVertexDatasource(graphName: string, typeName: string, options?: RawAxiosRequestConfig) {
        return DatasourceApiFp(this.configuration).unbindVertexDatasource(graphName, typeName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} component 
         * @param {string} podName 
         * @param {string} containerName 
         * @param {number} sinceSeconds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchLog: async (component: string, podName: string, containerName: string, sinceSeconds: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'component' is not null or undefined
            assertParamExists('fetchLog', 'component', component)
            // verify required parameter 'podName' is not null or undefined
            assertParamExists('fetchLog', 'podName', podName)
            // verify required parameter 'containerName' is not null or undefined
            assertParamExists('fetchLog', 'containerName', containerName)
            // verify required parameter 'sinceSeconds' is not null or undefined
            assertParamExists('fetchLog', 'sinceSeconds', sinceSeconds)
            const localVarPath = `/api/v1/deployment/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }

            if (podName !== undefined) {
                localVarQueryParameter['pod_name'] = podName;
            }

            if (containerName !== undefined) {
                localVarQueryParameter['container_name'] = containerName;
            }

            if (sinceSeconds !== undefined) {
                localVarQueryParameter['since_seconds'] = sinceSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deployment\'s meta info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/deployment/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deployment\'s status (k8s only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/deployment/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get node status (cpu/memory/disk, local only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/node/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} component 
         * @param {string} podName 
         * @param {string} containerName 
         * @param {number} sinceSeconds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchLog(component: string, podName: string, containerName: string, sinceSeconds: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchLog(component, podName, containerName, sinceSeconds, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeploymentApi.fetchLog']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get deployment\'s meta info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentInfo(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeploymentApi.getDeploymentInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get deployment\'s status (k8s only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentStatus(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeploymentApi.getDeploymentStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get node status (cpu/memory/disk, local only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeStatus(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeploymentApi.getNodeStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @param {string} component 
         * @param {string} podName 
         * @param {string} containerName 
         * @param {number} sinceSeconds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchLog(component: string, podName: string, containerName: string, sinceSeconds: number, options?: any): AxiosPromise<Array<DeploymentStatus>> {
            return localVarFp.fetchLog(component, podName, containerName, sinceSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deployment\'s meta info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentInfo(options?: any): AxiosPromise<DeploymentInfo> {
            return localVarFp.getDeploymentInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get deployment\'s status (k8s only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStatus(options?: any): AxiosPromise<Array<DeploymentStatus>> {
            return localVarFp.getDeploymentStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get node status (cpu/memory/disk, local only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeStatus(options?: any): AxiosPromise<Array<NodeStatus>> {
            return localVarFp.getNodeStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @param {string} component 
     * @param {string} podName 
     * @param {string} containerName 
     * @param {number} sinceSeconds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public fetchLog(component: string, podName: string, containerName: string, sinceSeconds: number, options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).fetchLog(component, podName, containerName, sinceSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deployment\'s meta info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentInfo(options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeploymentInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deployment\'s status (k8s only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentStatus(options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeploymentStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get node status (cpu/memory/disk, local only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getNodeStatus(options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getNodeStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a edge type
         * @param {string} graphName 
         * @param {EdgeType} edgeType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdgeType: async (graphName: string, edgeType: EdgeType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('createEdgeType', 'graphName', graphName)
            // verify required parameter 'edgeType' is not null or undefined
            assertParamExists('createEdgeType', 'edgeType', edgeType)
            const localVarPath = `/api/v1/graph/{graph_name}/schema/edge_type`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(edgeType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new graph
         * @param {Graph} graph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph: async (graph: Graph, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graph' is not null or undefined
            assertParamExists('createGraph', 'graph', graph)
            const localVarPath = `/api/v1/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a vertex type
         * @param {string} graphName 
         * @param {VertexType} vertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVertexType: async (graphName: string, vertexType: VertexType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('createVertexType', 'graphName', graphName)
            // verify required parameter 'vertexType' is not null or undefined
            assertParamExists('createVertexType', 'vertexType', vertexType)
            const localVarPath = `/api/v1/graph/{graph_name}/schema/vertex_type`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vertexType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a edge type by name
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEdgeType: async (graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('deleteEdgeType', 'graphName', graphName)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('deleteEdgeType', 'typeName', typeName)
            // verify required parameter 'sourceVertexType' is not null or undefined
            assertParamExists('deleteEdgeType', 'sourceVertexType', sourceVertexType)
            // verify required parameter 'destinationVertexType' is not null or undefined
            assertParamExists('deleteEdgeType', 'destinationVertexType', destinationVertexType)
            const localVarPath = `/api/v1/graph/{graph_name}/schema/edge_edge/{type_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceVertexType !== undefined) {
                localVarQueryParameter['source_vertex_type'] = sourceVertexType;
            }

            if (destinationVertexType !== undefined) {
                localVarQueryParameter['destination_vertex_type'] = destinationVertexType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a graph by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph: async (graphName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('deleteGraph', 'graphName', graphName)
            const localVarPath = `/api/v1/graph/{graph_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a vertex type by name
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVertexType: async (graphName: string, typeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('deleteVertexType', 'graphName', graphName)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('deleteVertexType', 'typeName', typeName)
            const localVarPath = `/api/v1/graph/{graph_name}/schema/vertex_type/{type_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get graph schema by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (graphName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('getSchema', 'graphName', graphName)
            const localVarPath = `/api/v1/graph/{graph_name}/schema`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all graphs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraphs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a edge type
         * @param {string} graphName 
         * @param {EdgeType} edgeType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEdgeType(graphName: string, edgeType: EdgeType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEdgeType(graphName, edgeType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.createEdgeType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new graph
         * @param {Graph} graph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGraph(graph: Graph, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(graph, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.createGraph']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a vertex type
         * @param {string} graphName 
         * @param {VertexType} vertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVertexType(graphName: string, vertexType: VertexType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVertexType(graphName, vertexType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.createVertexType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a edge type by name
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEdgeType(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEdgeType(graphName, typeName, sourceVertexType, destinationVertexType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.deleteEdgeType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a graph by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraph(graphName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraph(graphName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.deleteGraph']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a vertex type by name
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVertexType(graphName: string, typeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVertexType(graphName, typeName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.deleteVertexType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get graph schema by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(graphName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(graphName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.getSchema']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all graphs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGraphs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Graph>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGraphs(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.listGraphs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphApiFp(configuration)
    return {
        /**
         * Create a edge type
         * @param {string} graphName 
         * @param {EdgeType} edgeType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdgeType(graphName: string, edgeType: EdgeType, options?: any): AxiosPromise<string> {
            return localVarFp.createEdgeType(graphName, edgeType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new graph
         * @param {Graph} graph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph(graph: Graph, options?: any): AxiosPromise<string> {
            return localVarFp.createGraph(graph, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a vertex type
         * @param {string} graphName 
         * @param {VertexType} vertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVertexType(graphName: string, vertexType: VertexType, options?: any): AxiosPromise<string> {
            return localVarFp.createVertexType(graphName, vertexType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a edge type by name
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEdgeType(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteEdgeType(graphName, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a graph by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraph(graphName: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteGraph(graphName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a vertex type by name
         * @param {string} graphName 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVertexType(graphName: string, typeName: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteVertexType(graphName, typeName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get graph schema by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(graphName: string, options?: any): AxiosPromise<Schema> {
            return localVarFp.getSchema(graphName, options).then((request) => request(axios, basePath));
        },
        /**
         * List all graphs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraphs(options?: any): AxiosPromise<Array<Graph>> {
            return localVarFp.listGraphs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI {
    /**
     * Create a edge type
     * @param {string} graphName 
     * @param {EdgeType} edgeType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createEdgeType(graphName: string, edgeType: EdgeType, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).createEdgeType(graphName, edgeType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new graph
     * @param {Graph} graph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createGraph(graph: Graph, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).createGraph(graph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a vertex type
     * @param {string} graphName 
     * @param {VertexType} vertexType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createVertexType(graphName: string, vertexType: VertexType, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).createVertexType(graphName, vertexType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a edge type by name
     * @param {string} graphName 
     * @param {string} typeName 
     * @param {string} sourceVertexType 
     * @param {string} destinationVertexType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public deleteEdgeType(graphName: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).deleteEdgeType(graphName, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a graph by name
     * @param {string} graphName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public deleteGraph(graphName: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).deleteGraph(graphName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a vertex type by name
     * @param {string} graphName 
     * @param {string} typeName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public deleteVertexType(graphName: string, typeName: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).deleteVertexType(graphName, typeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get graph schema by name
     * @param {string} graphName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getSchema(graphName: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).getSchema(graphName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all graphs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public listGraphs(options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).listGraphs(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} graphName 
         * @param {SchemaMapping} schemaMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataloadingJob: async (graphName: string, schemaMapping: SchemaMapping, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('createDataloadingJob', 'graphName', graphName)
            // verify required parameter 'schemaMapping' is not null or undefined
            assertParamExists('createDataloadingJob', 'schemaMapping', schemaMapping)
            const localVarPath = `/api/v1/graph/{graph_name}/dataloading`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobById', 'jobId', jobId)
            const localVarPath = `/api/v1/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get dataloading configuration
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataloadingConfig: async (graphName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('getDataloadingConfig', 'graphName', graphName)
            const localVarPath = `/api/v1/graph/{graph_name}/dataloading/config`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobById', 'jobId', jobId)
            const localVarPath = `/api/v1/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} graphName 
         * @param {SchemaMapping} schemaMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataloadingJob(graphName: string, schemaMapping: SchemaMapping, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataloadingJob(graphName, schemaMapping, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.createDataloadingJob']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobById(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobById(jobId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.deleteJobById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * get dataloading configuration
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataloadingConfig(graphName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchemaMapping>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataloadingConfig(graphName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.getDataloadingConfig']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobById(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobById(jobId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.getJobById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<JobStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.listJobs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * 
         * @param {string} graphName 
         * @param {SchemaMapping} schemaMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataloadingJob(graphName: string, schemaMapping: SchemaMapping, options?: any): AxiosPromise<string> {
            return localVarFp.createDataloadingJob(graphName, schemaMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById(jobId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteJobById(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * get dataloading configuration
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataloadingConfig(graphName: string, options?: any): AxiosPromise<Array<SchemaMapping>> {
            return localVarFp.getDataloadingConfig(graphName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById(jobId: string, options?: any): AxiosPromise<JobStatus> {
            return localVarFp.getJobById(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(options?: any): AxiosPromise<Array<JobStatus>> {
            return localVarFp.listJobs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * 
     * @param {string} graphName 
     * @param {SchemaMapping} schemaMapping 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public createDataloadingJob(graphName: string, schemaMapping: SchemaMapping, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).createDataloadingJob(graphName, schemaMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public deleteJobById(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).deleteJobById(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get dataloading configuration
     * @param {string} graphName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getDataloadingConfig(graphName: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getDataloadingConfig(graphName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getJobById(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getJobById(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public listJobs(options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).listJobs(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LegacyApi - axios parameter creator
 * @export
 */
export const LegacyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get graph schema by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrootSchema: async (graphName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('getGrootSchema', 'graphName', graphName)
            const localVarPath = `/api/v1/groot/graph/{graph_name}/schema`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import schema to groot graph
         * @param {string} graphName 
         * @param {GrootSchema} grootSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGrootSchema: async (graphName: string, grootSchema: GrootSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('importGrootSchema', 'graphName', graphName)
            // verify required parameter 'grootSchema' is not null or undefined
            assertParamExists('importGrootSchema', 'grootSchema', grootSchema)
            const localVarPath = `/api/v1/groot/graph/{graph_name}/schema`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(grootSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list groot graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGrootGraph: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/groot/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LegacyApi - functional programming interface
 * @export
 */
export const LegacyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LegacyApiAxiosParamCreator(configuration)
    return {
        /**
         * Get graph schema by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrootSchema(graphName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrootSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGrootSchema(graphName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LegacyApi.getGrootSchema']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Import schema to groot graph
         * @param {string} graphName 
         * @param {GrootSchema} grootSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importGrootSchema(graphName: string, grootSchema: GrootSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importGrootSchema(graphName, grootSchema, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LegacyApi.importGrootSchema']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * list groot graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGrootGraph(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GrootGraph>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGrootGraph(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LegacyApi.listGrootGraph']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LegacyApi - factory interface
 * @export
 */
export const LegacyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LegacyApiFp(configuration)
    return {
        /**
         * Get graph schema by name
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrootSchema(graphName: string, options?: any): AxiosPromise<GrootSchema> {
            return localVarFp.getGrootSchema(graphName, options).then((request) => request(axios, basePath));
        },
        /**
         * Import schema to groot graph
         * @param {string} graphName 
         * @param {GrootSchema} grootSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGrootSchema(graphName: string, grootSchema: GrootSchema, options?: any): AxiosPromise<string> {
            return localVarFp.importGrootSchema(graphName, grootSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * list groot graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGrootGraph(options?: any): AxiosPromise<Array<GrootGraph>> {
            return localVarFp.listGrootGraph(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LegacyApi - object-oriented interface
 * @export
 * @class LegacyApi
 * @extends {BaseAPI}
 */
export class LegacyApi extends BaseAPI {
    /**
     * Get graph schema by name
     * @param {string} graphName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyApi
     */
    public getGrootSchema(graphName: string, options?: RawAxiosRequestConfig) {
        return LegacyApiFp(this.configuration).getGrootSchema(graphName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import schema to groot graph
     * @param {string} graphName 
     * @param {GrootSchema} grootSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyApi
     */
    public importGrootSchema(graphName: string, grootSchema: GrootSchema, options?: RawAxiosRequestConfig) {
        return LegacyApiFp(this.configuration).importGrootSchema(graphName, grootSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list groot graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyApi
     */
    public listGrootGraph(options?: RawAxiosRequestConfig) {
        return LegacyApiFp(this.configuration).listGrootGraph(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProcedureApi - axios parameter creator
 * @export
 */
export const ProcedureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new stored procedure on a certain graph
         * @param {string} graphName 
         * @param {Procedure} procedure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProcedure: async (graphName: string, procedure: Procedure, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('createProcedure', 'graphName', graphName)
            // verify required parameter 'procedure' is not null or undefined
            assertParamExists('createProcedure', 'procedure', procedure)
            const localVarPath = `/api/v1/graph/{graph_name}/procedure`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(procedure, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a stored procedure on a certain graph
         * @param {string} graphName 
         * @param {string} procedureName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcedure: async (graphName: string, procedureName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('deleteProcedure', 'graphName', graphName)
            // verify required parameter 'procedureName' is not null or undefined
            assertParamExists('deleteProcedure', 'procedureName', procedureName)
            const localVarPath = `/api/v1/graph/{graph_name}/procedure/{procedure_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)))
                .replace(`{${"procedure_name"}}`, encodeURIComponent(String(procedureName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the stored procedures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProcedures: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/procedure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List stored procedures on a certain graph
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProceduresByGraph: async (graphName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('listProceduresByGraph', 'graphName', graphName)
            const localVarPath = `/api/v1/graph/{graph_name}/procedure`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update stored procedure on a certain graph
         * @param {string} graphName 
         * @param {string} procedureName 
         * @param {Procedure} [procedure] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcedure: async (graphName: string, procedureName: string, procedure?: Procedure, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphName' is not null or undefined
            assertParamExists('updateProcedure', 'graphName', graphName)
            // verify required parameter 'procedureName' is not null or undefined
            assertParamExists('updateProcedure', 'procedureName', procedureName)
            const localVarPath = `/api/v1/graph/{graph_name}/procedure/{procedure_name}`
                .replace(`{${"graph_name"}}`, encodeURIComponent(String(graphName)))
                .replace(`{${"procedure_name"}}`, encodeURIComponent(String(procedureName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(procedure, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcedureApi - functional programming interface
 * @export
 */
export const ProcedureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcedureApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new stored procedure on a certain graph
         * @param {string} graphName 
         * @param {Procedure} procedure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProcedure(graphName: string, procedure: Procedure, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProcedure(graphName, procedure, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProcedureApi.createProcedure']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a stored procedure on a certain graph
         * @param {string} graphName 
         * @param {string} procedureName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcedure(graphName: string, procedureName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcedure(graphName, procedureName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProcedureApi.deleteProcedure']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all the stored procedures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProcedures(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Procedure>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProcedures(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProcedureApi.listProcedures']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List stored procedures on a certain graph
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProceduresByGraph(graphName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Procedure>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProceduresByGraph(graphName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProcedureApi.listProceduresByGraph']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update stored procedure on a certain graph
         * @param {string} graphName 
         * @param {string} procedureName 
         * @param {Procedure} [procedure] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcedure(graphName: string, procedureName: string, procedure?: Procedure, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcedure(graphName, procedureName, procedure, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProcedureApi.updateProcedure']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProcedureApi - factory interface
 * @export
 */
export const ProcedureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcedureApiFp(configuration)
    return {
        /**
         * Create a new stored procedure on a certain graph
         * @param {string} graphName 
         * @param {Procedure} procedure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProcedure(graphName: string, procedure: Procedure, options?: any): AxiosPromise<string> {
            return localVarFp.createProcedure(graphName, procedure, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a stored procedure on a certain graph
         * @param {string} graphName 
         * @param {string} procedureName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcedure(graphName: string, procedureName: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteProcedure(graphName, procedureName, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the stored procedures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProcedures(options?: any): AxiosPromise<Array<Procedure>> {
            return localVarFp.listProcedures(options).then((request) => request(axios, basePath));
        },
        /**
         * List stored procedures on a certain graph
         * @param {string} graphName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProceduresByGraph(graphName: string, options?: any): AxiosPromise<Array<Procedure>> {
            return localVarFp.listProceduresByGraph(graphName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update stored procedure on a certain graph
         * @param {string} graphName 
         * @param {string} procedureName 
         * @param {Procedure} [procedure] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcedure(graphName: string, procedureName: string, procedure?: Procedure, options?: any): AxiosPromise<string> {
            return localVarFp.updateProcedure(graphName, procedureName, procedure, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcedureApi - object-oriented interface
 * @export
 * @class ProcedureApi
 * @extends {BaseAPI}
 */
export class ProcedureApi extends BaseAPI {
    /**
     * Create a new stored procedure on a certain graph
     * @param {string} graphName 
     * @param {Procedure} procedure 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedureApi
     */
    public createProcedure(graphName: string, procedure: Procedure, options?: RawAxiosRequestConfig) {
        return ProcedureApiFp(this.configuration).createProcedure(graphName, procedure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a stored procedure on a certain graph
     * @param {string} graphName 
     * @param {string} procedureName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedureApi
     */
    public deleteProcedure(graphName: string, procedureName: string, options?: RawAxiosRequestConfig) {
        return ProcedureApiFp(this.configuration).deleteProcedure(graphName, procedureName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the stored procedures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedureApi
     */
    public listProcedures(options?: RawAxiosRequestConfig) {
        return ProcedureApiFp(this.configuration).listProcedures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List stored procedures on a certain graph
     * @param {string} graphName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedureApi
     */
    public listProceduresByGraph(graphName: string, options?: RawAxiosRequestConfig) {
        return ProcedureApiFp(this.configuration).listProceduresByGraph(graphName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update stored procedure on a certain graph
     * @param {string} graphName 
     * @param {string} procedureName 
     * @param {Procedure} [procedure] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcedureApi
     */
    public updateProcedure(graphName: string, procedureName: string, procedure?: Procedure, options?: RawAxiosRequestConfig) {
        return ProcedureApiFp(this.configuration).updateProcedure(graphName, procedureName, procedure, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restart current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartService: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service/restart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start service
         * @param {StartServiceRequest} [startServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startService: async (startServiceRequest?: StartServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopService: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceStatus(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.getServiceStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Restart current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartService(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartService(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.restartService']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Start service
         * @param {StartServiceRequest} [startServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startService(startServiceRequest?: StartServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startService(startServiceRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.startService']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Stop current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopService(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopService(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.stopService']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceApiFp(configuration)
    return {
        /**
         * Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceStatus(options?: any): AxiosPromise<ServiceStatus> {
            return localVarFp.getServiceStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Restart current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartService(options?: any): AxiosPromise<string> {
            return localVarFp.restartService(options).then((request) => request(axios, basePath));
        },
        /**
         * Start service
         * @param {StartServiceRequest} [startServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startService(startServiceRequest?: StartServiceRequest, options?: any): AxiosPromise<string> {
            return localVarFp.startService(startServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopService(options?: any): AxiosPromise<string> {
            return localVarFp.stopService(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     * Get service status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getServiceStatus(options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getServiceStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restart current service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public restartService(options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).restartService(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start service
     * @param {StartServiceRequest} [startServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public startService(startServiceRequest?: StartServiceRequest, options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).startService(startServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop current service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public stopService(options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).stopService(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UtilsApi - axios parameter creator
 * @export
 */
export const UtilsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {File} [filestorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (filestorage?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/file/uploading`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (filestorage !== undefined) { 
                localVarFormParams.append('filestorage', filestorage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {File} [filestorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(filestorage?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(filestorage, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UtilsApi.uploadFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilsApiFp(configuration)
    return {
        /**
         * 
         * @param {File} [filestorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(filestorage?: File, options?: any): AxiosPromise<string> {
            return localVarFp.uploadFile(filestorage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI {
    /**
     * 
     * @param {File} [filestorage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public uploadFile(filestorage?: File, options?: RawAxiosRequestConfig) {
        return UtilsApiFp(this.configuration).uploadFile(filestorage, options).then((request) => request(this.axios, this.basePath));
    }
}



