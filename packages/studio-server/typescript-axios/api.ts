/* tslint:disable */
/* eslint-disable */
/**
 * GraphScope FLEX HTTP SERVICE API
 * This is a specification for GraphScope FLEX HTTP service based on the OpenAPI 3.0 specification. You can find out more details about specification at [doc](https://swagger.io/specification/v3/).  Some useful links: - [GraphScope Repository](https://github.com/alibaba/GraphScope) - [The Source API definition for GraphScope Interactive](https://github.com/GraphScope/portal/tree/main/httpservice)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: graphscope@alibaba-inc.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BaseEdgeType
 */
export interface BaseEdgeType {
    /**
     * 
     * @type {string}
     * @memberof BaseEdgeType
     */
    'type_name': string;
    /**
     * 
     * @type {Array<BaseEdgeTypeVertexTypePairRelationsInner>}
     * @memberof BaseEdgeType
     */
    'vertex_type_pair_relations': Array<BaseEdgeTypeVertexTypePairRelationsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof BaseEdgeType
     */
    'directed'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseEdgeType
     */
    'primary_keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BaseEdgeTypeVertexTypePairRelationsInner
 */
export interface BaseEdgeTypeVertexTypePairRelationsInner {
    /**
     * 
     * @type {string}
     * @memberof BaseEdgeTypeVertexTypePairRelationsInner
     */
    'source_vertex': string;
    /**
     * 
     * @type {string}
     * @memberof BaseEdgeTypeVertexTypePairRelationsInner
     */
    'destination_vertex': string;
    /**
     * 
     * @type {string}
     * @memberof BaseEdgeTypeVertexTypePairRelationsInner
     */
    'relation': BaseEdgeTypeVertexTypePairRelationsInnerRelationEnum;
    /**
     * 
     * @type {BaseEdgeTypeVertexTypePairRelationsInnerXCsrParams}
     * @memberof BaseEdgeTypeVertexTypePairRelationsInner
     */
    'x_csr_params'?: BaseEdgeTypeVertexTypePairRelationsInnerXCsrParams;
}

export const BaseEdgeTypeVertexTypePairRelationsInnerRelationEnum = {
    ManyToMany: 'MANY_TO_MANY',
    OneToMany: 'ONE_TO_MANY',
    ManyToOne: 'MANY_TO_ONE',
    OneToOne: 'ONE_TO_ONE'
} as const;

export type BaseEdgeTypeVertexTypePairRelationsInnerRelationEnum = typeof BaseEdgeTypeVertexTypePairRelationsInnerRelationEnum[keyof typeof BaseEdgeTypeVertexTypePairRelationsInnerRelationEnum];

/**
 * Used for storage optimization
 * @export
 * @interface BaseEdgeTypeVertexTypePairRelationsInnerXCsrParams
 */
export interface BaseEdgeTypeVertexTypePairRelationsInnerXCsrParams {
    /**
     * 
     * @type {string}
     * @memberof BaseEdgeTypeVertexTypePairRelationsInnerXCsrParams
     */
    'edge_storage_strategy'?: BaseEdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum;
}

export const BaseEdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum = {
    OnlyIn: 'ONLY_IN',
    OnlyOut: 'ONLY_OUT',
    BothOutIn: 'BOTH_OUT_IN'
} as const;

export type BaseEdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum = typeof BaseEdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum[keyof typeof BaseEdgeTypeVertexTypePairRelationsInnerXCsrParamsEdgeStorageStrategyEnum];

/**
 * 
 * @export
 * @interface BasePropertyMeta
 */
export interface BasePropertyMeta {
    /**
     * 
     * @type {string}
     * @memberof BasePropertyMeta
     */
    'property_name': string;
    /**
     * 
     * @type {GSDataType}
     * @memberof BasePropertyMeta
     */
    'property_type': GSDataType;
    /**
     * 
     * @type {boolean}
     * @memberof BasePropertyMeta
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof BasePropertyMeta
     */
    'default_value'?: any;
    /**
     * 
     * @type {string}
     * @memberof BasePropertyMeta
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface BaseVertexType
 */
export interface BaseVertexType {
    /**
     * 
     * @type {string}
     * @memberof BaseVertexType
     */
    'type_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseVertexType
     */
    'primary_keys': Array<string>;
    /**
     * 
     * @type {BaseVertexTypeXCsrParams}
     * @memberof BaseVertexType
     */
    'x_csr_params'?: BaseVertexTypeXCsrParams;
}
/**
 * Used for storage optimization
 * @export
 * @interface BaseVertexTypeXCsrParams
 */
export interface BaseVertexTypeXCsrParams {
    /**
     * 
     * @type {number}
     * @memberof BaseVertexTypeXCsrParams
     */
    'max_vertex_num'?: number;
}
/**
 * 
 * @export
 * @interface ColumnMapping
 */
export interface ColumnMapping {
    /**
     * 
     * @type {ColumnMappingColumn}
     * @memberof ColumnMapping
     */
    'column': ColumnMappingColumn;
    /**
     * must align with the schema
     * @type {string}
     * @memberof ColumnMapping
     */
    'property': string;
}
/**
 * 
 * @export
 * @interface ColumnMappingColumn
 */
export interface ColumnMappingColumn {
    /**
     * 
     * @type {number}
     * @memberof ColumnMappingColumn
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof ColumnMappingColumn
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateAlertReceiverRequest
 */
export interface CreateAlertReceiverRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertReceiverRequest
     */
    'type': CreateAlertReceiverRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertReceiverRequest
     */
    'webhook_url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlertReceiverRequest
     */
    'at_user_ids': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlertReceiverRequest
     */
    'is_at_all': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlertReceiverRequest
     */
    'enable': boolean;
}

export const CreateAlertReceiverRequestTypeEnum = {
    Webhook: 'webhook'
} as const;

export type CreateAlertReceiverRequestTypeEnum = typeof CreateAlertReceiverRequestTypeEnum[keyof typeof CreateAlertReceiverRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateAlertRuleRequest
 */
export interface CreateAlertRuleRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertRuleRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertRuleRequest
     */
    'severity': CreateAlertRuleRequestSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertRuleRequest
     */
    'metric_type': CreateAlertRuleRequestMetricTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertRuleRequest
     */
    'conditions_description': string;
    /**
     * (mins)
     * @type {number}
     * @memberof CreateAlertRuleRequest
     */
    'frequency': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlertRuleRequest
     */
    'enable': boolean;
}

export const CreateAlertRuleRequestSeverityEnum = {
    Warning: 'warning',
    Emergency: 'emergency'
} as const;

export type CreateAlertRuleRequestSeverityEnum = typeof CreateAlertRuleRequestSeverityEnum[keyof typeof CreateAlertRuleRequestSeverityEnum];
export const CreateAlertRuleRequestMetricTypeEnum = {
    Node: 'node',
    Service: 'service'
} as const;

export type CreateAlertRuleRequestMetricTypeEnum = typeof CreateAlertRuleRequestMetricTypeEnum[keyof typeof CreateAlertRuleRequestMetricTypeEnum];

/**
 * 
 * @export
 * @interface CreateDataloadingJobResponse
 */
export interface CreateDataloadingJobResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateDataloadingJobResponse
     */
    'job_id': string;
}
/**
 * 
 * @export
 * @interface CreateEdgeType
 */
export interface CreateEdgeType {
    /**
     * 
     * @type {string}
     * @memberof CreateEdgeType
     */
    'type_name': string;
    /**
     * 
     * @type {Array<BaseEdgeTypeVertexTypePairRelationsInner>}
     * @memberof CreateEdgeType
     */
    'vertex_type_pair_relations': Array<BaseEdgeTypeVertexTypePairRelationsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateEdgeType
     */
    'directed'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateEdgeType
     */
    'primary_keys'?: Array<string>;
    /**
     * 
     * @type {Array<CreatePropertyMeta>}
     * @memberof CreateEdgeType
     */
    'properties': Array<CreatePropertyMeta>;
    /**
     * 
     * @type {string}
     * @memberof CreateEdgeType
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateGraphRequest
 */
export interface CreateGraphRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateGraphRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGraphRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<CreateStoredProcRequest>}
     * @memberof CreateGraphRequest
     */
    'stored_procedures'?: Array<CreateStoredProcRequest>;
    /**
     * 
     * @type {CreateGraphSchemaRequest}
     * @memberof CreateGraphRequest
     */
    'schema'?: CreateGraphSchemaRequest;
}
/**
 * 
 * @export
 * @interface CreateGraphResponse
 */
export interface CreateGraphResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateGraphResponse
     */
    'graph_id': string;
}
/**
 * 
 * @export
 * @interface CreateGraphSchemaRequest
 */
export interface CreateGraphSchemaRequest {
    /**
     * 
     * @type {Array<CreateVertexType>}
     * @memberof CreateGraphSchemaRequest
     */
    'vertex_types': Array<CreateVertexType>;
    /**
     * 
     * @type {Array<CreateEdgeType>}
     * @memberof CreateGraphSchemaRequest
     */
    'edge_types': Array<CreateEdgeType>;
}
/**
 * 
 * @export
 * @interface CreatePropertyMeta
 */
export interface CreatePropertyMeta {
    /**
     * 
     * @type {string}
     * @memberof CreatePropertyMeta
     */
    'property_name': string;
    /**
     * 
     * @type {GSDataType}
     * @memberof CreatePropertyMeta
     */
    'property_type': GSDataType;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePropertyMeta
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof CreatePropertyMeta
     */
    'default_value'?: object;
    /**
     * 
     * @type {string}
     * @memberof CreatePropertyMeta
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateStoredProcRequest
 */
export interface CreateStoredProcRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateStoredProcRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateStoredProcRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStoredProcRequest
     */
    'type': CreateStoredProcRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateStoredProcRequest
     */
    'query': string;
}

export const CreateStoredProcRequestTypeEnum = {
    Cpp: 'cpp',
    Cypher: 'cypher'
} as const;

export type CreateStoredProcRequestTypeEnum = typeof CreateStoredProcRequestTypeEnum[keyof typeof CreateStoredProcRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateStoredProcResponse
 */
export interface CreateStoredProcResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateStoredProcResponse
     */
    'stored_procedure_id': string;
}
/**
 * 
 * @export
 * @interface CreateVertexType
 */
export interface CreateVertexType {
    /**
     * 
     * @type {string}
     * @memberof CreateVertexType
     */
    'type_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateVertexType
     */
    'primary_keys': Array<string>;
    /**
     * 
     * @type {BaseVertexTypeXCsrParams}
     * @memberof CreateVertexType
     */
    'x_csr_params'?: BaseVertexTypeXCsrParams;
    /**
     * 
     * @type {Array<CreatePropertyMeta>}
     * @memberof CreateVertexType
     */
    'properties': Array<CreatePropertyMeta>;
    /**
     * 
     * @type {string}
     * @memberof CreateVertexType
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface DataloadingJobConfig
 */
export interface DataloadingJobConfig {
    /**
     * 
     * @type {DataloadingJobConfigLoadingConfig}
     * @memberof DataloadingJobConfig
     */
    'loading_config': DataloadingJobConfigLoadingConfig;
    /**
     * 
     * @type {Array<DataloadingJobConfigVerticesInner>}
     * @memberof DataloadingJobConfig
     */
    'vertices': Array<DataloadingJobConfigVerticesInner>;
    /**
     * 
     * @type {Array<DataloadingJobConfigEdgesInner>}
     * @memberof DataloadingJobConfig
     */
    'edges': Array<DataloadingJobConfigEdgesInner>;
    /**
     * format with \'2023-02-21 11:56:30\'
     * @type {string}
     * @memberof DataloadingJobConfig
     */
    'schedule'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DataloadingJobConfig
     */
    'repeat'?: DataloadingJobConfigRepeatEnum | null;
}

export const DataloadingJobConfigRepeatEnum = {
    Once: 'once',
    Day: 'day',
    Week: 'week'
} as const;

export type DataloadingJobConfigRepeatEnum = typeof DataloadingJobConfigRepeatEnum[keyof typeof DataloadingJobConfigRepeatEnum];

/**
 * 
 * @export
 * @interface DataloadingJobConfigEdgesInner
 */
export interface DataloadingJobConfigEdgesInner {
    /**
     * 
     * @type {string}
     * @memberof DataloadingJobConfigEdgesInner
     */
    'type_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataloadingJobConfigEdgesInner
     */
    'source_vertex'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataloadingJobConfigEdgesInner
     */
    'destination_vertex'?: string;
}
/**
 * 
 * @export
 * @interface DataloadingJobConfigLoadingConfig
 */
export interface DataloadingJobConfigLoadingConfig {
    /**
     * 
     * @type {string}
     * @memberof DataloadingJobConfigLoadingConfig
     */
    'import_option'?: DataloadingJobConfigLoadingConfigImportOptionEnum;
    /**
     * 
     * @type {DataloadingJobConfigLoadingConfigFormat}
     * @memberof DataloadingJobConfigLoadingConfig
     */
    'format'?: DataloadingJobConfigLoadingConfigFormat;
}

export const DataloadingJobConfigLoadingConfigImportOptionEnum = {
    Init: 'init',
    Overwrite: 'overwrite'
} as const;

export type DataloadingJobConfigLoadingConfigImportOptionEnum = typeof DataloadingJobConfigLoadingConfigImportOptionEnum[keyof typeof DataloadingJobConfigLoadingConfigImportOptionEnum];

/**
 * 
 * @export
 * @interface DataloadingJobConfigLoadingConfigFormat
 */
export interface DataloadingJobConfigLoadingConfigFormat {
    /**
     * 
     * @type {string}
     * @memberof DataloadingJobConfigLoadingConfigFormat
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DataloadingJobConfigLoadingConfigFormat
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DataloadingJobConfigVerticesInner
 */
export interface DataloadingJobConfigVerticesInner {
    /**
     * 
     * @type {string}
     * @memberof DataloadingJobConfigVerticesInner
     */
    'type_name'?: string;
}
/**
 * 
 * @export
 * @interface EdgeMapping
 */
export interface EdgeMapping {
    /**
     * 
     * @type {EdgeMappingTypeTriplet}
     * @memberof EdgeMapping
     */
    'type_triplet': EdgeMappingTypeTriplet;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgeMapping
     */
    'inputs': Array<string>;
    /**
     * 
     * @type {Array<ColumnMapping>}
     * @memberof EdgeMapping
     */
    'source_vertex_mappings': Array<ColumnMapping>;
    /**
     * 
     * @type {Array<ColumnMapping>}
     * @memberof EdgeMapping
     */
    'destination_vertex_mappings': Array<ColumnMapping>;
    /**
     * 
     * @type {Array<ColumnMapping>}
     * @memberof EdgeMapping
     */
    'column_mappings'?: Array<ColumnMapping>;
}
/**
 * source label -> [edge label] -> destination label
 * @export
 * @interface EdgeMappingTypeTriplet
 */
export interface EdgeMappingTypeTriplet {
    /**
     * 
     * @type {string}
     * @memberof EdgeMappingTypeTriplet
     */
    'edge': string;
    /**
     * 
     * @type {string}
     * @memberof EdgeMappingTypeTriplet
     */
    'source_vertex': string;
    /**
     * 
     * @type {string}
     * @memberof EdgeMappingTypeTriplet
     */
    'destination_vertex': string;
}
/**
 * @type GSDataType
 * @export
 */
export type GSDataType = PrimitiveType | StringType;

/**
 * 
 * @export
 * @interface GetAlertMessageResponse
 */
export interface GetAlertMessageResponse {
    /**
     * Generated in server side
     * @type {string}
     * @memberof GetAlertMessageResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetAlertMessageResponse
     */
    'alert_name': string;
    /**
     * 
     * @type {string}
     * @memberof GetAlertMessageResponse
     */
    'severity': GetAlertMessageResponseSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAlertMessageResponse
     */
    'metric_type': GetAlertMessageResponseMetricTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAlertMessageResponse
     */
    'target': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetAlertMessageResponse
     */
    'trigger_time': string;
    /**
     * 
     * @type {string}
     * @memberof GetAlertMessageResponse
     */
    'status': GetAlertMessageResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAlertMessageResponse
     */
    'message': string;
}

export const GetAlertMessageResponseSeverityEnum = {
    Warning: 'warning',
    Emergency: 'emergency'
} as const;

export type GetAlertMessageResponseSeverityEnum = typeof GetAlertMessageResponseSeverityEnum[keyof typeof GetAlertMessageResponseSeverityEnum];
export const GetAlertMessageResponseMetricTypeEnum = {
    Node: 'node',
    Service: 'service'
} as const;

export type GetAlertMessageResponseMetricTypeEnum = typeof GetAlertMessageResponseMetricTypeEnum[keyof typeof GetAlertMessageResponseMetricTypeEnum];
export const GetAlertMessageResponseStatusEnum = {
    Unsolved: 'unsolved',
    Solved: 'solved',
    Dealing: 'dealing'
} as const;

export type GetAlertMessageResponseStatusEnum = typeof GetAlertMessageResponseStatusEnum[keyof typeof GetAlertMessageResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetAlertReceiverResponse
 */
export interface GetAlertReceiverResponse {
    /**
     * 
     * @type {string}
     * @memberof GetAlertReceiverResponse
     */
    'type': GetAlertReceiverResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAlertReceiverResponse
     */
    'webhook_url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAlertReceiverResponse
     */
    'at_user_ids': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof GetAlertReceiverResponse
     */
    'is_at_all': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetAlertReceiverResponse
     */
    'enable': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetAlertReceiverResponse
     */
    'id': string;
    /**
     * Error message generated in server side
     * @type {string}
     * @memberof GetAlertReceiverResponse
     */
    'message': string;
}

export const GetAlertReceiverResponseTypeEnum = {
    Webhook: 'webhook'
} as const;

export type GetAlertReceiverResponseTypeEnum = typeof GetAlertReceiverResponseTypeEnum[keyof typeof GetAlertReceiverResponseTypeEnum];

/**
 * 
 * @export
 * @interface GetAlertRuleResponse
 */
export interface GetAlertRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof GetAlertRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetAlertRuleResponse
     */
    'severity': GetAlertRuleResponseSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAlertRuleResponse
     */
    'metric_type': GetAlertRuleResponseMetricTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAlertRuleResponse
     */
    'conditions_description': string;
    /**
     * (mins)
     * @type {number}
     * @memberof GetAlertRuleResponse
     */
    'frequency': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetAlertRuleResponse
     */
    'enable': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetAlertRuleResponse
     */
    'id': string;
}

export const GetAlertRuleResponseSeverityEnum = {
    Warning: 'warning',
    Emergency: 'emergency'
} as const;

export type GetAlertRuleResponseSeverityEnum = typeof GetAlertRuleResponseSeverityEnum[keyof typeof GetAlertRuleResponseSeverityEnum];
export const GetAlertRuleResponseMetricTypeEnum = {
    Node: 'node',
    Service: 'service'
} as const;

export type GetAlertRuleResponseMetricTypeEnum = typeof GetAlertRuleResponseMetricTypeEnum[keyof typeof GetAlertRuleResponseMetricTypeEnum];

/**
 * 
 * @export
 * @interface GetEdgeType
 */
export interface GetEdgeType {
    /**
     * 
     * @type {string}
     * @memberof GetEdgeType
     */
    'type_name': string;
    /**
     * 
     * @type {Array<BaseEdgeTypeVertexTypePairRelationsInner>}
     * @memberof GetEdgeType
     */
    'vertex_type_pair_relations': Array<BaseEdgeTypeVertexTypePairRelationsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof GetEdgeType
     */
    'directed'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEdgeType
     */
    'primary_keys'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GetEdgeType
     */
    'type_id': number;
    /**
     * 
     * @type {Array<GetPropertyMeta>}
     * @memberof GetEdgeType
     */
    'properties': Array<GetPropertyMeta>;
    /**
     * 
     * @type {string}
     * @memberof GetEdgeType
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface GetGraphResponse
 */
export interface GetGraphResponse {
    /**
     * 
     * @type {string}
     * @memberof GetGraphResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetGraphResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetGraphResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetGraphResponse
     */
    'store_type'?: GetGraphResponseStoreTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetGraphResponse
     */
    'creation_time': string;
    /**
     * 
     * @type {string}
     * @memberof GetGraphResponse
     */
    'data_update_time': string;
    /**
     * 
     * @type {string}
     * @memberof GetGraphResponse
     */
    'schema_update_time': string;
    /**
     * 
     * @type {Array<GetStoredProcResponse>}
     * @memberof GetGraphResponse
     */
    'stored_procedures'?: Array<GetStoredProcResponse>;
    /**
     * 
     * @type {GetGraphSchemaResponse}
     * @memberof GetGraphResponse
     */
    'schema': GetGraphSchemaResponse;
}

export const GetGraphResponseStoreTypeEnum = {
    MutableCsr: 'mutable_csr'
} as const;

export type GetGraphResponseStoreTypeEnum = typeof GetGraphResponseStoreTypeEnum[keyof typeof GetGraphResponseStoreTypeEnum];

/**
 * 
 * @export
 * @interface GetGraphSchemaResponse
 */
export interface GetGraphSchemaResponse {
    /**
     * 
     * @type {Array<GetVertexType>}
     * @memberof GetGraphSchemaResponse
     */
    'vertex_types': Array<GetVertexType>;
    /**
     * 
     * @type {Array<GetEdgeType>}
     * @memberof GetGraphSchemaResponse
     */
    'edge_types': Array<GetEdgeType>;
}
/**
 * 
 * @export
 * @interface GetPropertyMeta
 */
export interface GetPropertyMeta {
    /**
     * 
     * @type {string}
     * @memberof GetPropertyMeta
     */
    'property_name': string;
    /**
     * 
     * @type {GSDataType}
     * @memberof GetPropertyMeta
     */
    'property_type': GSDataType;
    /**
     * 
     * @type {boolean}
     * @memberof GetPropertyMeta
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetPropertyMeta
     */
    'default_value'?: object;
    /**
     * 
     * @type {string}
     * @memberof GetPropertyMeta
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetPropertyMeta
     */
    'property_id': number;
}
/**
 * 
 * @export
 * @interface GetStoredProcResponse
 */
export interface GetStoredProcResponse {
    /**
     * 
     * @type {string}
     * @memberof GetStoredProcResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetStoredProcResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetStoredProcResponse
     */
    'type': GetStoredProcResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetStoredProcResponse
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof GetStoredProcResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetStoredProcResponse
     */
    'library': string;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof GetStoredProcResponse
     */
    'params': Array<Parameter>;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof GetStoredProcResponse
     */
    'returns': Array<Parameter>;
    /**
     * 
     * @type {string}
     * @memberof GetStoredProcResponse
     */
    'bound_graph': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetStoredProcResponse
     */
    'runnable': boolean;
}

export const GetStoredProcResponseTypeEnum = {
    Cpp: 'cpp',
    Cypher: 'cypher'
} as const;

export type GetStoredProcResponseTypeEnum = typeof GetStoredProcResponseTypeEnum[keyof typeof GetStoredProcResponseTypeEnum];

/**
 * 
 * @export
 * @interface GetVertexType
 */
export interface GetVertexType {
    /**
     * 
     * @type {string}
     * @memberof GetVertexType
     */
    'type_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetVertexType
     */
    'primary_keys': Array<string>;
    /**
     * 
     * @type {BaseVertexTypeXCsrParams}
     * @memberof GetVertexType
     */
    'x_csr_params'?: BaseVertexTypeXCsrParams;
    /**
     * 
     * @type {number}
     * @memberof GetVertexType
     */
    'type_id': number;
    /**
     * 
     * @type {Array<GetPropertyMeta>}
     * @memberof GetVertexType
     */
    'properties': Array<GetPropertyMeta>;
    /**
     * 
     * @type {string}
     * @memberof GetVertexType
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface JobStatus
 */
export interface JobStatus {
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'status': JobStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobStatus
     */
    'end_time'?: string;
    /**
     * logview URL or log string
     * @type {string}
     * @memberof JobStatus
     */
    'log'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JobStatus
     */
    'detail'?: { [key: string]: any; };
}

export const JobStatusStatusEnum = {
    Running: 'RUNNING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Cancelled: 'CANCELLED',
    Waiting: 'WAITING'
} as const;

export type JobStatusStatusEnum = typeof JobStatusStatusEnum[keyof typeof JobStatusStatusEnum];

/**
 * 
 * @export
 * @interface LongText
 */
export interface LongText {
    /**
     * 
     * @type {string}
     * @memberof LongText
     */
    'long_text': string | null;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error code
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface NodeStatus
 */
export interface NodeStatus {
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof NodeStatus
     */
    'cpu_usage': number;
    /**
     * 
     * @type {number}
     * @memberof NodeStatus
     */
    'memory_usage': number;
    /**
     * 
     * @type {number}
     * @memberof NodeStatus
     */
    'disk_usage': number;
}
/**
 * 
 * @export
 * @interface Parameter
 */
export interface Parameter {
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    'name': string;
    /**
     * 
     * @type {GSDataType}
     * @memberof Parameter
     */
    'type': GSDataType;
}
/**
 * 
 * @export
 * @interface PrimitiveType
 */
export interface PrimitiveType {
    /**
     * 
     * @type {string}
     * @memberof PrimitiveType
     */
    'primitive_type': PrimitiveTypePrimitiveTypeEnum;
}

export const PrimitiveTypePrimitiveTypeEnum = {
    SignedInt32: 'DT_SIGNED_INT32',
    UnsignedInt32: 'DT_UNSIGNED_INT32',
    SignedInt64: 'DT_SIGNED_INT64',
    UnsignedInt64: 'DT_UNSIGNED_INT64',
    Bool: 'DT_BOOL',
    Float: 'DT_FLOAT',
    Double: 'DT_DOUBLE'
} as const;

export type PrimitiveTypePrimitiveTypeEnum = typeof PrimitiveTypePrimitiveTypeEnum[keyof typeof PrimitiveTypePrimitiveTypeEnum];

/**
 * 
 * @export
 * @interface RunningDeploymentInfo
 */
export interface RunningDeploymentInfo {
    /**
     * 
     * @type {string}
     * @memberof RunningDeploymentInfo
     */
    'instance_name': string;
    /**
     * 
     * @type {string}
     * @memberof RunningDeploymentInfo
     */
    'cluster_type': RunningDeploymentInfoClusterTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RunningDeploymentInfo
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof RunningDeploymentInfo
     */
    'creation_time': string;
    /**
     * 
     * @type {string}
     * @memberof RunningDeploymentInfo
     */
    'frontend': RunningDeploymentInfoFrontendEnum;
    /**
     * 
     * @type {string}
     * @memberof RunningDeploymentInfo
     */
    'engine': RunningDeploymentInfoEngineEnum;
    /**
     * 
     * @type {string}
     * @memberof RunningDeploymentInfo
     */
    'storage': RunningDeploymentInfoStorageEnum;
}

export const RunningDeploymentInfoClusterTypeEnum = {
    Hosts: 'HOSTS',
    Kubernetes: 'KUBERNETES'
} as const;

export type RunningDeploymentInfoClusterTypeEnum = typeof RunningDeploymentInfoClusterTypeEnum[keyof typeof RunningDeploymentInfoClusterTypeEnum];
export const RunningDeploymentInfoFrontendEnum = {
    CypherGremlin: 'Cypher/Gremlin',
    AnalyticalApps: 'AnalyticalApps'
} as const;

export type RunningDeploymentInfoFrontendEnum = typeof RunningDeploymentInfoFrontendEnum[keyof typeof RunningDeploymentInfoFrontendEnum];
export const RunningDeploymentInfoEngineEnum = {
    Hiactor: 'Hiactor',
    Gaia: 'Gaia'
} as const;

export type RunningDeploymentInfoEngineEnum = typeof RunningDeploymentInfoEngineEnum[keyof typeof RunningDeploymentInfoEngineEnum];
export const RunningDeploymentInfoStorageEnum = {
    MutableCsr: 'MutableCSR'
} as const;

export type RunningDeploymentInfoStorageEnum = typeof RunningDeploymentInfoStorageEnum[keyof typeof RunningDeploymentInfoStorageEnum];

/**
 * 
 * @export
 * @interface RunningDeploymentStatus
 */
export interface RunningDeploymentStatus {
    /**
     * 
     * @type {string}
     * @memberof RunningDeploymentStatus
     */
    'cluster_type': RunningDeploymentStatusClusterTypeEnum;
    /**
     * 
     * @type {Array<RunningDeploymentStatusNodesInner>}
     * @memberof RunningDeploymentStatus
     */
    'nodes': Array<RunningDeploymentStatusNodesInner>;
}

export const RunningDeploymentStatusClusterTypeEnum = {
    Hosts: 'HOSTS',
    Kubernetes: 'KUBERNETES'
} as const;

export type RunningDeploymentStatusClusterTypeEnum = typeof RunningDeploymentStatusClusterTypeEnum[keyof typeof RunningDeploymentStatusClusterTypeEnum];

/**
 * @type RunningDeploymentStatusNodesInner
 * @export
 */
export type RunningDeploymentStatusNodesInner = NodeStatus;

/**
 * 
 * @export
 * @interface SchemaMapping
 */
export interface SchemaMapping {
    /**
     * 
     * @type {Array<VertexMapping>}
     * @memberof SchemaMapping
     */
    'vertex_mappings': Array<VertexMapping>;
    /**
     * 
     * @type {Array<EdgeMapping>}
     * @memberof SchemaMapping
     */
    'edge_mappings': Array<EdgeMapping>;
}
/**
 * 
 * @export
 * @interface ServiceStatus
 */
export interface ServiceStatus {
    /**
     * 
     * @type {string}
     * @memberof ServiceStatus
     */
    'graph_id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatus
     */
    'status': ServiceStatusStatusEnum;
    /**
     * 
     * @type {ServiceStatusSdkEndpoints}
     * @memberof ServiceStatus
     */
    'sdk_endpoints'?: ServiceStatusSdkEndpoints;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatus
     */
    'start_time'?: string;
}

export const ServiceStatusStatusEnum = {
    Running: 'Running',
    Stopped: 'Stopped'
} as const;

export type ServiceStatusStatusEnum = typeof ServiceStatusStatusEnum[keyof typeof ServiceStatusStatusEnum];

/**
 * 
 * @export
 * @interface ServiceStatusSdkEndpoints
 */
export interface ServiceStatusSdkEndpoints {
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusSdkEndpoints
     */
    'cypher'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusSdkEndpoints
     */
    'gremlin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusSdkEndpoints
     */
    'hqps'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceStatusSdkEndpoints
     */
    'grpc'?: string;
}
/**
 * 
 * @export
 * @interface StartServiceRequest
 */
export interface StartServiceRequest {
    /**
     * 
     * @type {string}
     * @memberof StartServiceRequest
     */
    'graph_id'?: string;
}
/**
 * 
 * @export
 * @interface StoredProcedureMeta
 */
export interface StoredProcedureMeta {
    /**
     * 
     * @type {string}
     * @memberof StoredProcedureMeta
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StoredProcedureMeta
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof StoredProcedureMeta
     */
    'type': StoredProcedureMetaTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StoredProcedureMeta
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof StoredProcedureMeta
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoredProcedureMeta
     */
    'library': string;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof StoredProcedureMeta
     */
    'params': Array<Parameter>;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof StoredProcedureMeta
     */
    'returns': Array<Parameter>;
}

export const StoredProcedureMetaTypeEnum = {
    Cpp: 'cpp',
    Cypher: 'cypher'
} as const;

export type StoredProcedureMetaTypeEnum = typeof StoredProcedureMetaTypeEnum[keyof typeof StoredProcedureMetaTypeEnum];

/**
 * 
 * @export
 * @interface StringType
 */
export interface StringType {
    /**
     * 
     * @type {StringTypeString}
     * @memberof StringType
     */
    'string': StringTypeString;
}
/**
 * @type StringTypeString
 * @export
 */
export type StringTypeString = LongText;

/**
 * 
 * @export
 * @interface UpdateAlertMessageStatusRequest
 */
export interface UpdateAlertMessageStatusRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateAlertMessageStatusRequest
     */
    'message_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateAlertMessageStatusRequest
     */
    'status': UpdateAlertMessageStatusRequestStatusEnum;
}

export const UpdateAlertMessageStatusRequestStatusEnum = {
    Unsolved: 'unsolved',
    Solved: 'solved',
    Dealing: 'dealing'
} as const;

export type UpdateAlertMessageStatusRequestStatusEnum = typeof UpdateAlertMessageStatusRequestStatusEnum[keyof typeof UpdateAlertMessageStatusRequestStatusEnum];

/**
 * 
 * @export
 * @interface UpdateStoredProcRequest
 */
export interface UpdateStoredProcRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateStoredProcRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponse
     */
    'file_path': string;
}
/**
 * 
 * @export
 * @interface VertexMapping
 */
export interface VertexMapping {
    /**
     * 
     * @type {string}
     * @memberof VertexMapping
     */
    'type_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VertexMapping
     */
    'inputs': Array<string>;
    /**
     * 
     * @type {Array<ColumnMapping>}
     * @memberof VertexMapping
     */
    'column_mappings': Array<ColumnMapping>;
}

/**
 * AlertApi - axios parameter creator
 * @export
 */
export const AlertApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new alert receiver
         * @param {CreateAlertReceiverRequest} createAlertReceiverRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertReceiver: async (createAlertReceiverRequest: CreateAlertReceiverRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlertReceiverRequest' is not null or undefined
            assertParamExists('createAlertReceiver', 'createAlertReceiverRequest', createAlertReceiverRequest)
            const localVarPath = `/api/v1/alert/receiver`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertReceiverRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alert message in batch
         * @param {string} messageIds A list of message id separated by comma, e.g. id1,id2,id3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertMessageInBatch: async (messageIds: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageIds' is not null or undefined
            assertParamExists('deleteAlertMessageInBatch', 'messageIds', messageIds)
            const localVarPath = `/api/v1/alert/message-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (messageIds !== undefined) {
                localVarQueryParameter['message_ids'] = messageIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the alert receiver by ID
         * @param {string} receiverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertReceiverById: async (receiverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receiverId' is not null or undefined
            assertParamExists('deleteAlertReceiverById', 'receiverId', receiverId)
            const localVarPath = `/api/v1/alert/receiver/{receiver_id}`
                .replace(`{${"receiver_id"}}`, encodeURIComponent(String(receiverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertRuleByID: async (ruleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('deleteAlertRuleByID', 'ruleId', ruleId)
            const localVarPath = `/api/v1/alert/rule/{rule_id}`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert messages
         * @param {string} [alertType] 
         * @param {ListAlertMessagesStatusEnum} [status] 
         * @param {ListAlertMessagesSeverityEnum} [severity] 
         * @param {string} [startTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {string} [endTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertMessages: async (alertType?: string, status?: ListAlertMessagesStatusEnum, severity?: ListAlertMessagesSeverityEnum, startTime?: string, endTime?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alert/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (alertType !== undefined) {
                localVarQueryParameter['alert_type'] = alertType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (severity !== undefined) {
                localVarQueryParameter['severity'] = severity;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertReceivers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alert/receiver`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alert/rule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the message status in batch
         * @param {UpdateAlertMessageStatusRequest} [updateAlertMessageStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertMessageInBatch: async (updateAlertMessageStatusRequest?: UpdateAlertMessageStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alert/message-collection/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAlertMessageStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update alert receiver by ID
         * @param {string} receiverId 
         * @param {CreateAlertReceiverRequest} [createAlertReceiverRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertReceiverById: async (receiverId: string, createAlertReceiverRequest?: CreateAlertReceiverRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receiverId' is not null or undefined
            assertParamExists('updateAlertReceiverById', 'receiverId', receiverId)
            const localVarPath = `/api/v1/alert/receiver/{receiver_id}`
                .replace(`{${"receiver_id"}}`, encodeURIComponent(String(receiverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertReceiverRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ruleId 
         * @param {CreateAlertRuleRequest} [createAlertRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertRuleByID: async (ruleId: string, createAlertRuleRequest?: CreateAlertRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('updateAlertRuleByID', 'ruleId', ruleId)
            const localVarPath = `/api/v1/alert/rule/{rule_id}`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertApi - functional programming interface
 * @export
 */
export const AlertApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new alert receiver
         * @param {CreateAlertReceiverRequest} createAlertReceiverRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertReceiver(createAlertReceiverRequest: CreateAlertReceiverRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertReceiver(createAlertReceiverRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.createAlertReceiver']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete alert message in batch
         * @param {string} messageIds A list of message id separated by comma, e.g. id1,id2,id3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertMessageInBatch(messageIds: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertMessageInBatch(messageIds, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.deleteAlertMessageInBatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete the alert receiver by ID
         * @param {string} receiverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertReceiverById(receiverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertReceiverById(receiverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.deleteAlertReceiverById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertRuleByID(ruleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertRuleByID(ruleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.deleteAlertRuleByID']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all alert messages
         * @param {string} [alertType] 
         * @param {ListAlertMessagesStatusEnum} [status] 
         * @param {ListAlertMessagesSeverityEnum} [severity] 
         * @param {string} [startTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {string} [endTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertMessages(alertType?: string, status?: ListAlertMessagesStatusEnum, severity?: ListAlertMessagesSeverityEnum, startTime?: string, endTime?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAlertMessageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertMessages(alertType, status, severity, startTime, endTime, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.listAlertMessages']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all alert receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertReceivers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAlertReceiverResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertReceivers(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.listAlertReceivers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all alert rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAlertRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertRules(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.listAlertRules']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update the message status in batch
         * @param {UpdateAlertMessageStatusRequest} [updateAlertMessageStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlertMessageInBatch(updateAlertMessageStatusRequest?: UpdateAlertMessageStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlertMessageInBatch(updateAlertMessageStatusRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.updateAlertMessageInBatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update alert receiver by ID
         * @param {string} receiverId 
         * @param {CreateAlertReceiverRequest} [createAlertReceiverRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlertReceiverById(receiverId: string, createAlertReceiverRequest?: CreateAlertReceiverRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlertReceiverById(receiverId, createAlertReceiverRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.updateAlertReceiverById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} ruleId 
         * @param {CreateAlertRuleRequest} [createAlertRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlertRuleByID(ruleId: string, createAlertRuleRequest?: CreateAlertRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlertRuleByID(ruleId, createAlertRuleRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AlertApi.updateAlertRuleByID']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AlertApi - factory interface
 * @export
 */
export const AlertApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertApiFp(configuration)
    return {
        /**
         * Create a new alert receiver
         * @param {CreateAlertReceiverRequest} createAlertReceiverRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertReceiver(createAlertReceiverRequest: CreateAlertReceiverRequest, options?: any): AxiosPromise<string> {
            return localVarFp.createAlertReceiver(createAlertReceiverRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alert message in batch
         * @param {string} messageIds A list of message id separated by comma, e.g. id1,id2,id3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertMessageInBatch(messageIds: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteAlertMessageInBatch(messageIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the alert receiver by ID
         * @param {string} receiverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertReceiverById(receiverId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteAlertReceiverById(receiverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ruleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertRuleByID(ruleId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteAlertRuleByID(ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert messages
         * @param {string} [alertType] 
         * @param {ListAlertMessagesStatusEnum} [status] 
         * @param {ListAlertMessagesSeverityEnum} [severity] 
         * @param {string} [startTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {string} [endTime] format with \&quot;2023-02-21-11-56-30\&quot;
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertMessages(alertType?: string, status?: ListAlertMessagesStatusEnum, severity?: ListAlertMessagesSeverityEnum, startTime?: string, endTime?: string, limit?: number, options?: any): AxiosPromise<Array<GetAlertMessageResponse>> {
            return localVarFp.listAlertMessages(alertType, status, severity, startTime, endTime, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertReceivers(options?: any): AxiosPromise<Array<GetAlertReceiverResponse>> {
            return localVarFp.listAlertReceivers(options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertRules(options?: any): AxiosPromise<Array<GetAlertRuleResponse>> {
            return localVarFp.listAlertRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the message status in batch
         * @param {UpdateAlertMessageStatusRequest} [updateAlertMessageStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertMessageInBatch(updateAlertMessageStatusRequest?: UpdateAlertMessageStatusRequest, options?: any): AxiosPromise<string> {
            return localVarFp.updateAlertMessageInBatch(updateAlertMessageStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update alert receiver by ID
         * @param {string} receiverId 
         * @param {CreateAlertReceiverRequest} [createAlertReceiverRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertReceiverById(receiverId: string, createAlertReceiverRequest?: CreateAlertReceiverRequest, options?: any): AxiosPromise<string> {
            return localVarFp.updateAlertReceiverById(receiverId, createAlertReceiverRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ruleId 
         * @param {CreateAlertRuleRequest} [createAlertRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlertRuleByID(ruleId: string, createAlertRuleRequest?: CreateAlertRuleRequest, options?: any): AxiosPromise<string> {
            return localVarFp.updateAlertRuleByID(ruleId, createAlertRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertApi - object-oriented interface
 * @export
 * @class AlertApi
 * @extends {BaseAPI}
 */
export class AlertApi extends BaseAPI {
    /**
     * Create a new alert receiver
     * @param {CreateAlertReceiverRequest} createAlertReceiverRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public createAlertReceiver(createAlertReceiverRequest: CreateAlertReceiverRequest, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).createAlertReceiver(createAlertReceiverRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alert message in batch
     * @param {string} messageIds A list of message id separated by comma, e.g. id1,id2,id3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public deleteAlertMessageInBatch(messageIds: string, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).deleteAlertMessageInBatch(messageIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the alert receiver by ID
     * @param {string} receiverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public deleteAlertReceiverById(receiverId: string, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).deleteAlertReceiverById(receiverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ruleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public deleteAlertRuleByID(ruleId: string, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).deleteAlertRuleByID(ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all alert messages
     * @param {string} [alertType] 
     * @param {ListAlertMessagesStatusEnum} [status] 
     * @param {ListAlertMessagesSeverityEnum} [severity] 
     * @param {string} [startTime] format with \&quot;2023-02-21-11-56-30\&quot;
     * @param {string} [endTime] format with \&quot;2023-02-21-11-56-30\&quot;
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public listAlertMessages(alertType?: string, status?: ListAlertMessagesStatusEnum, severity?: ListAlertMessagesSeverityEnum, startTime?: string, endTime?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).listAlertMessages(alertType, status, severity, startTime, endTime, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all alert receivers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public listAlertReceivers(options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).listAlertReceivers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all alert rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public listAlertRules(options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).listAlertRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the message status in batch
     * @param {UpdateAlertMessageStatusRequest} [updateAlertMessageStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public updateAlertMessageInBatch(updateAlertMessageStatusRequest?: UpdateAlertMessageStatusRequest, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).updateAlertMessageInBatch(updateAlertMessageStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update alert receiver by ID
     * @param {string} receiverId 
     * @param {CreateAlertReceiverRequest} [createAlertReceiverRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public updateAlertReceiverById(receiverId: string, createAlertReceiverRequest?: CreateAlertReceiverRequest, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).updateAlertReceiverById(receiverId, createAlertReceiverRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ruleId 
     * @param {CreateAlertRuleRequest} [createAlertRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public updateAlertRuleByID(ruleId: string, createAlertRuleRequest?: CreateAlertRuleRequest, options?: RawAxiosRequestConfig) {
        return AlertApiFp(this.configuration).updateAlertRuleByID(ruleId, createAlertRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListAlertMessagesStatusEnum = {
    Solved: 'solved',
    Unsolved: 'unsolved',
    Dealing: 'dealing'
} as const;
export type ListAlertMessagesStatusEnum = typeof ListAlertMessagesStatusEnum[keyof typeof ListAlertMessagesStatusEnum];
/**
 * @export
 */
export const ListAlertMessagesSeverityEnum = {
    Warning: 'warning',
    Emergency: 'emergency'
} as const;
export type ListAlertMessagesSeverityEnum = typeof ListAlertMessagesSeverityEnum[keyof typeof ListAlertMessagesSeverityEnum];


/**
 * DataSourceApi - axios parameter creator
 * @export
 */
export const DataSourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bind data sources in batches
         * @param {string} graphId 
         * @param {SchemaMapping} schemaMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindDatasourceInBatch: async (graphId: string, schemaMapping: SchemaMapping, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('bindDatasourceInBatch', 'graphId', graphId)
            // verify required parameter 'schemaMapping' is not null or undefined
            assertParamExists('bindDatasourceInBatch', 'schemaMapping', schemaMapping)
            const localVarPath = `/api/v1/graph/{graph_id}/datasource`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get data source by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasourceById: async (graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getDatasourceById', 'graphId', graphId)
            const localVarPath = `/api/v1/graph/{graph_id}/datasource`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unbind datas ource on an edge type
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindEdgeDatasource: async (graphId: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('unbindEdgeDatasource', 'graphId', graphId)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('unbindEdgeDatasource', 'typeName', typeName)
            // verify required parameter 'sourceVertexType' is not null or undefined
            assertParamExists('unbindEdgeDatasource', 'sourceVertexType', sourceVertexType)
            // verify required parameter 'destinationVertexType' is not null or undefined
            assertParamExists('unbindEdgeDatasource', 'destinationVertexType', destinationVertexType)
            const localVarPath = `/api/v1/graph/{graph_id}/datasource/edge/{type_name}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceVertexType !== undefined) {
                localVarQueryParameter['source_vertex_type'] = sourceVertexType;
            }

            if (destinationVertexType !== undefined) {
                localVarQueryParameter['destination_vertex_type'] = destinationVertexType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unbind data source on a vertex type
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindVertexDatasource: async (graphId: string, typeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('unbindVertexDatasource', 'graphId', graphId)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('unbindVertexDatasource', 'typeName', typeName)
            const localVarPath = `/api/v1/graph/{graph_id}/datasource/vertex/{type_name}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataSourceApi - functional programming interface
 * @export
 */
export const DataSourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Bind data sources in batches
         * @param {string} graphId 
         * @param {SchemaMapping} schemaMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindDatasourceInBatch(graphId: string, schemaMapping: SchemaMapping, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindDatasourceInBatch(graphId, schemaMapping, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DataSourceApi.bindDatasourceInBatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get data source by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasourceById(graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasourceById(graphId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DataSourceApi.getDatasourceById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unbind datas ource on an edge type
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindEdgeDatasource(graphId: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindEdgeDatasource(graphId, typeName, sourceVertexType, destinationVertexType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DataSourceApi.unbindEdgeDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unbind data source on a vertex type
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindVertexDatasource(graphId: string, typeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindVertexDatasource(graphId, typeName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DataSourceApi.unbindVertexDatasource']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DataSourceApi - factory interface
 * @export
 */
export const DataSourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataSourceApiFp(configuration)
    return {
        /**
         * Bind data sources in batches
         * @param {string} graphId 
         * @param {SchemaMapping} schemaMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindDatasourceInBatch(graphId: string, schemaMapping: SchemaMapping, options?: any): AxiosPromise<string> {
            return localVarFp.bindDatasourceInBatch(graphId, schemaMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * Get data source by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasourceById(graphId: string, options?: any): AxiosPromise<SchemaMapping> {
            return localVarFp.getDatasourceById(graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unbind datas ource on an edge type
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindEdgeDatasource(graphId: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: any): AxiosPromise<string> {
            return localVarFp.unbindEdgeDatasource(graphId, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(axios, basePath));
        },
        /**
         * Unbind data source on a vertex type
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindVertexDatasource(graphId: string, typeName: string, options?: any): AxiosPromise<string> {
            return localVarFp.unbindVertexDatasource(graphId, typeName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceApi - object-oriented interface
 * @export
 * @class DataSourceApi
 * @extends {BaseAPI}
 */
export class DataSourceApi extends BaseAPI {
    /**
     * Bind data sources in batches
     * @param {string} graphId 
     * @param {SchemaMapping} schemaMapping 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceApi
     */
    public bindDatasourceInBatch(graphId: string, schemaMapping: SchemaMapping, options?: RawAxiosRequestConfig) {
        return DataSourceApiFp(this.configuration).bindDatasourceInBatch(graphId, schemaMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get data source by ID
     * @param {string} graphId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceApi
     */
    public getDatasourceById(graphId: string, options?: RawAxiosRequestConfig) {
        return DataSourceApiFp(this.configuration).getDatasourceById(graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unbind datas ource on an edge type
     * @param {string} graphId 
     * @param {string} typeName 
     * @param {string} sourceVertexType 
     * @param {string} destinationVertexType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceApi
     */
    public unbindEdgeDatasource(graphId: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig) {
        return DataSourceApiFp(this.configuration).unbindEdgeDatasource(graphId, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unbind data source on a vertex type
     * @param {string} graphId 
     * @param {string} typeName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceApi
     */
    public unbindVertexDatasource(graphId: string, typeName: string, options?: RawAxiosRequestConfig) {
        return DataSourceApiFp(this.configuration).unbindVertexDatasource(graphId, typeName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deployment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/deployment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deployment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/deployment/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Deployment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunningDeploymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentInfo(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeploymentApi.getDeploymentInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deployment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunningDeploymentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentStatus(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DeploymentApi.getDeploymentStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * Deployment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentInfo(options?: any): AxiosPromise<RunningDeploymentInfo> {
            return localVarFp.getDeploymentInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Deployment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStatus(options?: any): AxiosPromise<RunningDeploymentStatus> {
            return localVarFp.getDeploymentStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * Deployment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentInfo(options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeploymentInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deployment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentStatus(options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeploymentStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a edge type
         * @param {string} graphId 
         * @param {CreateEdgeType} [createEdgeType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdgeType: async (graphId: string, createEdgeType?: CreateEdgeType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('createEdgeType', 'graphId', graphId)
            const localVarPath = `/api/v1/graph/{graph_id}/schema/edge`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEdgeType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new graph
         * @param {CreateGraphRequest} createGraphRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph: async (createGraphRequest: CreateGraphRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGraphRequest' is not null or undefined
            assertParamExists('createGraph', 'createGraphRequest', createGraphRequest)
            const localVarPath = `/api/v1/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGraphRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a vertex type
         * @param {string} graphId 
         * @param {CreateVertexType} createVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVertexType: async (graphId: string, createVertexType: CreateVertexType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('createVertexType', 'graphId', graphId)
            // verify required parameter 'createVertexType' is not null or undefined
            assertParamExists('createVertexType', 'createVertexType', createVertexType)
            const localVarPath = `/api/v1/graph/{graph_id}/schema/vertex`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVertexType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete edge type by name
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEdgeTypeByName: async (graphId: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('deleteEdgeTypeByName', 'graphId', graphId)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('deleteEdgeTypeByName', 'typeName', typeName)
            // verify required parameter 'sourceVertexType' is not null or undefined
            assertParamExists('deleteEdgeTypeByName', 'sourceVertexType', sourceVertexType)
            // verify required parameter 'destinationVertexType' is not null or undefined
            assertParamExists('deleteEdgeTypeByName', 'destinationVertexType', destinationVertexType)
            const localVarPath = `/api/v1/graph/{graph_id}/schema/edge/{type_name}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceVertexType !== undefined) {
                localVarQueryParameter['source_vertex_type'] = sourceVertexType;
            }

            if (destinationVertexType !== undefined) {
                localVarQueryParameter['destination_vertex_type'] = destinationVertexType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete graph by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphById: async (graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('deleteGraphById', 'graphId', graphId)
            const localVarPath = `/api/v1/graph/{graph_id}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete vertex type by name
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVertexTypeByName: async (graphId: string, typeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('deleteVertexTypeByName', 'graphId', graphId)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('deleteVertexTypeByName', 'typeName', typeName)
            const localVarPath = `/api/v1/graph/{graph_id}/schema/vertex/{type_name}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"type_name"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get graph by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphById: async (graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getGraphById', 'graphId', graphId)
            const localVarPath = `/api/v1/graph/{graph_id}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get graph schema by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaById: async (graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getSchemaById', 'graphId', graphId)
            const localVarPath = `/api/v1/graph/{graph_id}/schema`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import graph schema
         * @param {string} graphId 
         * @param {CreateGraphSchemaRequest} createGraphSchemaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSchemaById: async (graphId: string, createGraphSchemaRequest: CreateGraphSchemaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('importSchemaById', 'graphId', graphId)
            // verify required parameter 'createGraphSchemaRequest' is not null or undefined
            assertParamExists('importSchemaById', 'createGraphSchemaRequest', createGraphSchemaRequest)
            const localVarPath = `/api/v1/graph/{graph_id}/schema`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGraphSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all graphs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraphs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a edge type
         * @param {string} graphId 
         * @param {CreateEdgeType} [createEdgeType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEdgeType(graphId: string, createEdgeType?: CreateEdgeType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEdgeType(graphId, createEdgeType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.createEdgeType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new graph
         * @param {CreateGraphRequest} createGraphRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGraph(createGraphRequest: CreateGraphRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateGraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(createGraphRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.createGraph']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a vertex type
         * @param {string} graphId 
         * @param {CreateVertexType} createVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVertexType(graphId: string, createVertexType: CreateVertexType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVertexType(graphId, createVertexType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.createVertexType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete edge type by name
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEdgeTypeByName(graphId: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEdgeTypeByName(graphId, typeName, sourceVertexType, destinationVertexType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.deleteEdgeTypeByName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete graph by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraphById(graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraphById(graphId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.deleteGraphById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete vertex type by name
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVertexTypeByName(graphId: string, typeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVertexTypeByName(graphId, typeName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.deleteVertexTypeByName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get graph by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraphById(graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraphById(graphId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.getGraphById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get graph schema by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchemaById(graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGraphSchemaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchemaById(graphId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.getSchemaById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Import graph schema
         * @param {string} graphId 
         * @param {CreateGraphSchemaRequest} createGraphSchemaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importSchemaById(graphId: string, createGraphSchemaRequest: CreateGraphSchemaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSchemaById(graphId, createGraphSchemaRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.importSchemaById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all graphs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGraphs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetGraphResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGraphs(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GraphApi.listGraphs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphApiFp(configuration)
    return {
        /**
         * Create a edge type
         * @param {string} graphId 
         * @param {CreateEdgeType} [createEdgeType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdgeType(graphId: string, createEdgeType?: CreateEdgeType, options?: any): AxiosPromise<string> {
            return localVarFp.createEdgeType(graphId, createEdgeType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new graph
         * @param {CreateGraphRequest} createGraphRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph(createGraphRequest: CreateGraphRequest, options?: any): AxiosPromise<CreateGraphResponse> {
            return localVarFp.createGraph(createGraphRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a vertex type
         * @param {string} graphId 
         * @param {CreateVertexType} createVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVertexType(graphId: string, createVertexType: CreateVertexType, options?: any): AxiosPromise<string> {
            return localVarFp.createVertexType(graphId, createVertexType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete edge type by name
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {string} sourceVertexType 
         * @param {string} destinationVertexType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEdgeTypeByName(graphId: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteEdgeTypeByName(graphId, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete graph by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphById(graphId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteGraphById(graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete vertex type by name
         * @param {string} graphId 
         * @param {string} typeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVertexTypeByName(graphId: string, typeName: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteVertexTypeByName(graphId, typeName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get graph by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphById(graphId: string, options?: any): AxiosPromise<GetGraphResponse> {
            return localVarFp.getGraphById(graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get graph schema by ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaById(graphId: string, options?: any): AxiosPromise<GetGraphSchemaResponse> {
            return localVarFp.getSchemaById(graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import graph schema
         * @param {string} graphId 
         * @param {CreateGraphSchemaRequest} createGraphSchemaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSchemaById(graphId: string, createGraphSchemaRequest: CreateGraphSchemaRequest, options?: any): AxiosPromise<string> {
            return localVarFp.importSchemaById(graphId, createGraphSchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List all graphs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraphs(options?: any): AxiosPromise<Array<GetGraphResponse>> {
            return localVarFp.listGraphs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI {
    /**
     * Create a edge type
     * @param {string} graphId 
     * @param {CreateEdgeType} [createEdgeType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createEdgeType(graphId: string, createEdgeType?: CreateEdgeType, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).createEdgeType(graphId, createEdgeType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new graph
     * @param {CreateGraphRequest} createGraphRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createGraph(createGraphRequest: CreateGraphRequest, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).createGraph(createGraphRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a vertex type
     * @param {string} graphId 
     * @param {CreateVertexType} createVertexType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createVertexType(graphId: string, createVertexType: CreateVertexType, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).createVertexType(graphId, createVertexType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete edge type by name
     * @param {string} graphId 
     * @param {string} typeName 
     * @param {string} sourceVertexType 
     * @param {string} destinationVertexType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public deleteEdgeTypeByName(graphId: string, typeName: string, sourceVertexType: string, destinationVertexType: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).deleteEdgeTypeByName(graphId, typeName, sourceVertexType, destinationVertexType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete graph by ID
     * @param {string} graphId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public deleteGraphById(graphId: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).deleteGraphById(graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete vertex type by name
     * @param {string} graphId 
     * @param {string} typeName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public deleteVertexTypeByName(graphId: string, typeName: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).deleteVertexTypeByName(graphId, typeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get graph by ID
     * @param {string} graphId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getGraphById(graphId: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).getGraphById(graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get graph schema by ID
     * @param {string} graphId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getSchemaById(graphId: string, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).getSchemaById(graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import graph schema
     * @param {string} graphId 
     * @param {CreateGraphSchemaRequest} createGraphSchemaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public importSchemaById(graphId: string, createGraphSchemaRequest: CreateGraphSchemaRequest, options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).importSchemaById(graphId, createGraphSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all graphs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public listGraphs(options?: RawAxiosRequestConfig) {
        return GraphApiFp(this.configuration).listGraphs(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete job by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobById', 'jobId', jobId)
            const localVarPath = `/api/v1/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the data loading configuration
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataloadingJobConfig: async (graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getDataloadingJobConfig', 'graphId', graphId)
            const localVarPath = `/api/v1/graph/{graph_id}/dataloading/config`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get job status by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobById', 'jobId', jobId)
            const localVarPath = `/api/v1/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a dataloading job
         * @param {string} graphId 
         * @param {DataloadingJobConfig} dataloadingJobConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDataloadingJob: async (graphId: string, dataloadingJobConfig: DataloadingJobConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('submitDataloadingJob', 'graphId', graphId)
            // verify required parameter 'dataloadingJobConfig' is not null or undefined
            assertParamExists('submitDataloadingJob', 'dataloadingJobConfig', dataloadingJobConfig)
            const localVarPath = `/api/v1/graph/{graph_id}/dataloading`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataloadingJobConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete job by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobById(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobById(jobId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.deleteJobById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the data loading configuration
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataloadingJobConfig(graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataloadingJobConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataloadingJobConfig(graphId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.getDataloadingJobConfig']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get job status by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobById(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobById(jobId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.getJobById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<JobStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.listJobs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submit a dataloading job
         * @param {string} graphId 
         * @param {DataloadingJobConfig} dataloadingJobConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitDataloadingJob(graphId: string, dataloadingJobConfig: DataloadingJobConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDataloadingJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitDataloadingJob(graphId, dataloadingJobConfig, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['JobApi.submitDataloadingJob']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * Delete job by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById(jobId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteJobById(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the data loading configuration
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataloadingJobConfig(graphId: string, options?: any): AxiosPromise<DataloadingJobConfig> {
            return localVarFp.getDataloadingJobConfig(graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get job status by ID
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById(jobId: string, options?: any): AxiosPromise<JobStatus> {
            return localVarFp.getJobById(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(options?: any): AxiosPromise<Array<JobStatus>> {
            return localVarFp.listJobs(options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a dataloading job
         * @param {string} graphId 
         * @param {DataloadingJobConfig} dataloadingJobConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDataloadingJob(graphId: string, dataloadingJobConfig: DataloadingJobConfig, options?: any): AxiosPromise<CreateDataloadingJobResponse> {
            return localVarFp.submitDataloadingJob(graphId, dataloadingJobConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * Delete job by ID
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public deleteJobById(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).deleteJobById(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the data loading configuration
     * @param {string} graphId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getDataloadingJobConfig(graphId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getDataloadingJobConfig(graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get job status by ID
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getJobById(jobId: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getJobById(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public listJobs(options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).listJobs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a dataloading job
     * @param {string} graphId 
     * @param {DataloadingJobConfig} dataloadingJobConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public submitDataloadingJob(graphId: string, dataloadingJobConfig: DataloadingJobConfig, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).submitDataloadingJob(graphId, dataloadingJobConfig, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get service status by graph ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceStatusById: async (graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getServiceStatusById', 'graphId', graphId)
            const localVarPath = `/api/v1/graph/{graph_id}/service`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restart current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartService: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service/restart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start service
         * @param {StartServiceRequest} [startServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startService: async (startServiceRequest?: StartServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopService: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get service status by graph ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceStatusById(graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceStatusById(graphId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.getServiceStatusById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServiceStatus(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.listServiceStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Restart current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartService(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartService(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.restartService']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Start service
         * @param {StartServiceRequest} [startServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startService(startServiceRequest?: StartServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startService(startServiceRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.startService']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Stop current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopService(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopService(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceApi.stopService']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceApiFp(configuration)
    return {
        /**
         * Get service status by graph ID
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceStatusById(graphId: string, options?: any): AxiosPromise<ServiceStatus> {
            return localVarFp.getServiceStatusById(graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceStatus(options?: any): AxiosPromise<Array<ServiceStatus>> {
            return localVarFp.listServiceStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Restart current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartService(options?: any): AxiosPromise<string> {
            return localVarFp.restartService(options).then((request) => request(axios, basePath));
        },
        /**
         * Start service
         * @param {StartServiceRequest} [startServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startService(startServiceRequest?: StartServiceRequest, options?: any): AxiosPromise<string> {
            return localVarFp.startService(startServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop current service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopService(options?: any): AxiosPromise<string> {
            return localVarFp.stopService(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     * Get service status by graph ID
     * @param {string} graphId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getServiceStatusById(graphId: string, options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getServiceStatusById(graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all service status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public listServiceStatus(options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).listServiceStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restart current service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public restartService(options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).restartService(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start service
     * @param {StartServiceRequest} [startServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public startService(startServiceRequest?: StartServiceRequest, options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).startService(startServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop current service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public stopService(options?: RawAxiosRequestConfig) {
        return ServiceApiFp(this.configuration).stopService(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StoredProcedureApi - axios parameter creator
 * @export
 */
export const StoredProcedureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new stored procedure on a certain graph
         * @param {string} graphId 
         * @param {CreateStoredProcRequest} createStoredProcRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStoredProcedure: async (graphId: string, createStoredProcRequest: CreateStoredProcRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('createStoredProcedure', 'graphId', graphId)
            // verify required parameter 'createStoredProcRequest' is not null or undefined
            assertParamExists('createStoredProcedure', 'createStoredProcRequest', createStoredProcRequest)
            const localVarPath = `/api/v1/graph/{graph_id}/storedproc`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStoredProcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStoredProcedureById: async (graphId: string, storedProcedureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('deleteStoredProcedureById', 'graphId', graphId)
            // verify required parameter 'storedProcedureId' is not null or undefined
            assertParamExists('deleteStoredProcedureById', 'storedProcedureId', storedProcedureId)
            const localVarPath = `/api/v1/graph/{graph_id}/storedproc/{stored_procedure_id}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"stored_procedure_id"}}`, encodeURIComponent(String(storedProcedureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoredProcedureById: async (graphId: string, storedProcedureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getStoredProcedureById', 'graphId', graphId)
            // verify required parameter 'storedProcedureId' is not null or undefined
            assertParamExists('getStoredProcedureById', 'storedProcedureId', storedProcedureId)
            const localVarPath = `/api/v1/graph/{graph_id}/storedproc/{stored_procedure_id}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"stored_procedure_id"}}`, encodeURIComponent(String(storedProcedureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all stored procedures on a certain graph
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStoredProcedures: async (graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('listStoredProcedures', 'graphId', graphId)
            const localVarPath = `/api/v1/graph/{graph_id}/storedproc`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {UpdateStoredProcRequest} [updateStoredProcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStoredProcedureById: async (graphId: string, storedProcedureId: string, updateStoredProcRequest?: UpdateStoredProcRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('updateStoredProcedureById', 'graphId', graphId)
            // verify required parameter 'storedProcedureId' is not null or undefined
            assertParamExists('updateStoredProcedureById', 'storedProcedureId', storedProcedureId)
            const localVarPath = `/api/v1/graph/{graph_id}/storedproc/{stored_procedure_id}`
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"stored_procedure_id"}}`, encodeURIComponent(String(storedProcedureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStoredProcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoredProcedureApi - functional programming interface
 * @export
 */
export const StoredProcedureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoredProcedureApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new stored procedure on a certain graph
         * @param {string} graphId 
         * @param {CreateStoredProcRequest} createStoredProcRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStoredProcedure(graphId: string, createStoredProcRequest: CreateStoredProcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateStoredProcResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStoredProcedure(graphId, createStoredProcRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StoredProcedureApi.createStoredProcedure']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStoredProcedureById(graphId: string, storedProcedureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStoredProcedureById(graphId, storedProcedureId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StoredProcedureApi.deleteStoredProcedureById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoredProcedureById(graphId: string, storedProcedureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStoredProcResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoredProcedureById(graphId, storedProcedureId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StoredProcedureApi.getStoredProcedureById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all stored procedures on a certain graph
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStoredProcedures(graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetStoredProcResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStoredProcedures(graphId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StoredProcedureApi.listStoredProcedures']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {UpdateStoredProcRequest} [updateStoredProcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStoredProcedureById(graphId: string, storedProcedureId: string, updateStoredProcRequest?: UpdateStoredProcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStoredProcedureById(graphId, storedProcedureId, updateStoredProcRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StoredProcedureApi.updateStoredProcedureById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StoredProcedureApi - factory interface
 * @export
 */
export const StoredProcedureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoredProcedureApiFp(configuration)
    return {
        /**
         * Create a new stored procedure on a certain graph
         * @param {string} graphId 
         * @param {CreateStoredProcRequest} createStoredProcRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStoredProcedure(graphId: string, createStoredProcRequest: CreateStoredProcRequest, options?: any): AxiosPromise<CreateStoredProcResponse> {
            return localVarFp.createStoredProcedure(graphId, createStoredProcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStoredProcedureById(graphId: string, storedProcedureId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteStoredProcedureById(graphId, storedProcedureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoredProcedureById(graphId: string, storedProcedureId: string, options?: any): AxiosPromise<GetStoredProcResponse> {
            return localVarFp.getStoredProcedureById(graphId, storedProcedureId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all stored procedures on a certain graph
         * @param {string} graphId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStoredProcedures(graphId: string, options?: any): AxiosPromise<Array<GetStoredProcResponse>> {
            return localVarFp.listStoredProcedures(graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a stored procedure by ID
         * @param {string} graphId 
         * @param {string} storedProcedureId 
         * @param {UpdateStoredProcRequest} [updateStoredProcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStoredProcedureById(graphId: string, storedProcedureId: string, updateStoredProcRequest?: UpdateStoredProcRequest, options?: any): AxiosPromise<string> {
            return localVarFp.updateStoredProcedureById(graphId, storedProcedureId, updateStoredProcRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoredProcedureApi - object-oriented interface
 * @export
 * @class StoredProcedureApi
 * @extends {BaseAPI}
 */
export class StoredProcedureApi extends BaseAPI {
    /**
     * Create a new stored procedure on a certain graph
     * @param {string} graphId 
     * @param {CreateStoredProcRequest} createStoredProcRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoredProcedureApi
     */
    public createStoredProcedure(graphId: string, createStoredProcRequest: CreateStoredProcRequest, options?: RawAxiosRequestConfig) {
        return StoredProcedureApiFp(this.configuration).createStoredProcedure(graphId, createStoredProcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a stored procedure by ID
     * @param {string} graphId 
     * @param {string} storedProcedureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoredProcedureApi
     */
    public deleteStoredProcedureById(graphId: string, storedProcedureId: string, options?: RawAxiosRequestConfig) {
        return StoredProcedureApiFp(this.configuration).deleteStoredProcedureById(graphId, storedProcedureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a stored procedure by ID
     * @param {string} graphId 
     * @param {string} storedProcedureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoredProcedureApi
     */
    public getStoredProcedureById(graphId: string, storedProcedureId: string, options?: RawAxiosRequestConfig) {
        return StoredProcedureApiFp(this.configuration).getStoredProcedureById(graphId, storedProcedureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all stored procedures on a certain graph
     * @param {string} graphId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoredProcedureApi
     */
    public listStoredProcedures(graphId: string, options?: RawAxiosRequestConfig) {
        return StoredProcedureApiFp(this.configuration).listStoredProcedures(graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a stored procedure by ID
     * @param {string} graphId 
     * @param {string} storedProcedureId 
     * @param {UpdateStoredProcRequest} [updateStoredProcRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoredProcedureApi
     */
    public updateStoredProcedureById(graphId: string, storedProcedureId: string, updateStoredProcRequest?: UpdateStoredProcRequest, options?: RawAxiosRequestConfig) {
        return StoredProcedureApiFp(this.configuration).updateStoredProcedureById(graphId, storedProcedureId, updateStoredProcRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UtilsApi - axios parameter creator
 * @export
 */
export const UtilsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {File} [filestorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (filestorage?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/file/uploading`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (filestorage !== undefined) { 
                localVarFormParams.append('filestorage', filestorage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {File} [filestorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(filestorage?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(filestorage, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UtilsApi.uploadFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilsApiFp(configuration)
    return {
        /**
         * 
         * @param {File} [filestorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(filestorage?: File, options?: any): AxiosPromise<UploadFileResponse> {
            return localVarFp.uploadFile(filestorage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI {
    /**
     * 
     * @param {File} [filestorage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public uploadFile(filestorage?: File, options?: RawAxiosRequestConfig) {
        return UtilsApiFp(this.configuration).uploadFile(filestorage, options).then((request) => request(this.axios, this.basePath));
    }
}



